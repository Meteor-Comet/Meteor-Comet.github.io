---
layout: post
title:  "WPF学习指南 - 2026"
date:   2026-01-23 10:00:00 +0800
categories: C# WPF Windows
---

# WPF学习指南 - 2026

## 1. WPF概述

### 1.1 什么是WPF

Windows Presentation Foundation (WPF) 是微软推出的基于 .NET Framework 的用户界面框架，用于创建 Windows 桌面应用程序。WPF 提供了丰富的图形、动画和交互功能，支持数据绑定、样式、模板等现代 UI 开发特性，是构建现代化 Windows 应用程序的理想选择。

WPF 于 2006 年随 .NET Framework 3.0 一起发布，旨在替代传统的 Windows Forms 技术，提供更现代、更灵活的 UI 开发体验。

### 1.2 WPF的体系结构

WPF 的体系结构由以下几个主要部分组成：

1. **表示子系统**：负责渲染和显示 UI 元素，包括：
   - DirectX 渲染引擎：使用 DirectX 进行硬件加速渲染
   - 媒体集成：支持音频、视频和 3D 内容
   - 文本渲染：基于 ClearType 技术的高质量文本渲染

2. **内容呈现系统**：定义 UI 元素的结构和行为，包括：
   - 视觉树（Visual Tree）：表示 UI 的实际渲染结构
   - 逻辑树（Logical Tree）：表示应用程序定义的 UI 结构
   - 元素树（Element Tree）：逻辑树的扩展，包含更多的布局信息

3. **应用程序模型**：提供应用程序的生命周期管理，包括：
   - 应用程序启动和关闭
   - 窗口管理
   - 导航系统

4. **核心服务**：提供各种支持功能，包括：
   - 数据绑定
   - 样式和模板
   - 资源系统
   - 命令系统
   - 事件系统

### 1.3 WPF与WinForms的区别

| 特性 | WPF | WinForms |
|------|-----|----------|
| 渲染引擎 | DirectX 硬件加速 | GDI+ 软件渲染 |
| UI 定义 | XAML（声明式） | 代码（命令式） |
| 布局系统 | 灵活的布局面板（Grid、StackPanel等） | 固定位置和大小 |
| 数据绑定 | 强大的双向数据绑定 | 有限的数据绑定能力 |
| 样式和模板 | 丰富的样式和模板系统 | 有限的样式支持 |
| 动画支持 | 内置动画系统 | 需要第三方库或自定义实现 |
| 3D 支持 | 内置 3D 渲染能力 | 不支持 |
| 分辨率独立性 | 基于设备无关单位 | 基于像素 |
| 学习曲线 | 较陡峭 | 较平缓 |

## 2. XAML基础

### 2.1 XAML简介

XAML（Extensible Application Markup Language）是一种声明式标记语言，用于定义 WPF 应用程序的用户界面。XAML 基于 XML，提供了一种简洁、直观的方式来创建和布局 UI 元素。

XAML 的主要优点：
- 声明式语法，使 UI 定义更加清晰
- 与代码分离，提高代码的可维护性
- 工具支持良好，Visual Studio 和 Blend 都提供了可视化编辑功能
- 支持复杂的对象初始化和属性设置

### 2.2 XAML元素与属性

XAML 中的每个元素对应一个 .NET 类，属性对应类的属性。例如：

```xaml
<!-- 元素 = 类，属性 = 类的属性 -->
<Button Content="Click Me" Width="100" Height="30" />

<!-- 等同于 C# 代码 -->
// Button button = new Button();
// button.Content = "Click Me";
// button.Width = 100;
// button.Height = 30;
```

XAML 元素可以包含子元素，这对应于对象的组合关系：

```xaml
<Grid>
    <Button Content="Click Me" />
</Grid>

<!-- 等同于 C# 代码 -->
// Grid grid = new Grid();
// Button button = new Button();
// button.Content = "Click Me";
// grid.Children.Add(button);
```

### 2.3 对象与属性初始化

XAML 提供了多种方式来初始化对象和设置属性：

1. **属性语法**：使用属性名和值的方式设置属性
   ```xaml
   <Button Width="100" Height="30" />
   ```

2. **元素语法**：使用子元素的方式设置属性
   ```xaml
   <Button>
       <Button.Width>100</Button.Width>
       <Button.Height>30</Button.Height>
   </Button>
   ```

3. **内容语法**：对于只有一个内容属性的元素，可以直接设置内容
   ```xaml
   <Button>Click Me</Button>
   ```

4. **集合语法**：对于集合类型的属性，可以使用子元素添加集合项
   ```xaml
   <Grid>
       <Grid.ColumnDefinitions>
           <ColumnDefinition Width="*" />
           <ColumnDefinition Width="*" />
       </Grid.ColumnDefinitions>
   </Grid>
   ```

5. **标记扩展**：使用特殊的语法来引用其他对象或执行特殊操作
   ```xaml
   <Button Content="{Binding ButtonText}" />
   ```

### 2.4 XAML命名空间

XAML 文件中的命名空间定义了可用的元素和类型：

```xaml
<Window x:Class="MyWpfApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:MyWpfApp"
        Title="MainWindow" Height="450" Width="800">
    <!-- 内容 -->
</Window>
```

- `xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`：WPF 核心命名空间，包含所有 UI 元素
- `xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`：XAML 语言命名空间，包含 XAML 特定的功能
- `xmlns:local="clr-namespace:MyWpfApp"`：本地命名空间，引用当前项目中的类型

## 3. WPF布局系统

### 3.1 布局面板概览

WPF 提供了多种布局面板，用于组织和排列 UI 元素：

| 布局面板 | 描述 | 适用场景 |
|---------|------|----------|
| Grid | 网格布局，支持行列划分 | 复杂布局，需要精确定位 |
| StackPanel | 堆叠布局，水平或垂直排列 | 简单的线性排列 |
| WrapPanel | 自动换行的堆叠布局 | 动态数量的元素排列 |
| DockPanel | 停靠布局，元素可以停靠在边缘 | 工具栏、状态栏等 |
| Canvas | 画布布局，使用绝对坐标定位 | 自定义绘图、游戏界面 |
| UniformGrid | 均匀网格布局，所有单元格大小相同 | 图标网格、棋盘等 |
| Viewbox | 自动缩放内容以适应容器 | 需要自适应大小的内容 |

### 3.2 Grid布局

Grid 是最常用的布局面板，它允许通过定义行和列来创建复杂的布局：

```xaml
<Grid>
    <!-- 定义列 -->
    <Grid.ColumnDefinitions>
        <ColumnDefinition Width="100" /> <!-- 固定宽度 -->
        <ColumnDefinition Width="*" /> <!-- 自适应宽度 -->
        <ColumnDefinition Width="2*" /> <!-- 自适应宽度，是前一列的两倍 -->
    </Grid.ColumnDefinitions>
    
    <!-- 定义行 -->
    <Grid.RowDefinitions>
        <RowDefinition Height="50" /> <!-- 固定高度 -->
        <RowDefinition Height="*" /> <!-- 自适应高度 -->
        <RowDefinition Height="40" /> <!-- 固定高度 -->
    </Grid.RowDefinitions>
    
    <!-- 放置控件 -->
    <Label Content="用户名:" Grid.Column="0" Grid.Row="0" VerticalAlignment="Center" />
    <TextBox Grid.Column="1" Grid.Row="0" Grid.ColumnSpan="2" Margin="5" />
    
    <Label Content="密码:" Grid.Column="0" Grid.Row="1" VerticalAlignment="Top" Margin="0,5,0,0" />
    <PasswordBox Grid.Column="1" Grid.Row="1" Grid.ColumnSpan="2" Margin="5" />
    
    <Button Content="登录" Grid.Column="1" Grid.Row="2" HorizontalAlignment="Right" Margin="5" />
    <Button Content="取消" Grid.Column="2" Grid.Row="2" HorizontalAlignment="Left" Margin="5" />
</Grid>
```

### 3.3 StackPanel与WrapPanel

StackPanel 用于创建简单的线性布局，元素可以水平或垂直排列：

```xaml
<!-- 垂直排列 -->
<StackPanel Orientation="Vertical" Margin="10" Padding="10" Background="LightGray">
    <TextBlock Text="个人信息" FontSize="16" FontWeight="Bold" Margin="0,0,0,10" />
    <StackPanel Orientation="Horizontal" Margin="0,5,0,5">
        <TextBlock Text="姓名:" Width="80" VerticalAlignment="Center" />
        <TextBox Width="200" />
    </StackPanel>
    <StackPanel Orientation="Horizontal" Margin="0,5,0,5">
        <TextBlock Text="年龄:" Width="80" VerticalAlignment="Center" />
        <TextBox Width="200" />
    </StackPanel>
    <StackPanel Orientation="Horizontal" Margin="0,10,0,0" HorizontalAlignment="Right">
        <Button Content="保存" Margin="0,0,10,0" />
        <Button Content="取消" />
    </StackPanel>
</StackPanel>
```

WrapPanel 类似于 StackPanel，但当元素超出容器边界时会自动换行：

```xaml
<WrapPanel Orientation="Horizontal" Margin="10" Padding="10" Background="LightGray">
    <Button Content="按钮 1" Margin="5" Width="100" />
    <Button Content="按钮 2" Margin="5" Width="100" />
    <Button Content="按钮 3" Margin="5" Width="100" />
    <Button Content="按钮 4" Margin="5" Width="100" />
    <Button Content="按钮 5" Margin="5" Width="100" />
    <Button Content="按钮 6" Margin="5" Width="100" />
</WrapPanel>
```

### 3.4 DockPanel与Canvas

DockPanel 允许元素停靠在容器的边缘：

```xaml
<DockPanel LastChildFill="True">
    <Menu DockPanel.Dock="Top">
        <MenuItem Header="文件">
            <MenuItem Header="新建" />
            <MenuItem Header="打开" />
            <MenuItem Header="保存" />
        </MenuItem>
        <MenuItem Header="编辑">
            <MenuItem Header="复制" />
            <MenuItem Header="粘贴" />
        </MenuItem>
    </Menu>
    
    <ToolBar DockPanel.Dock="Top">
        <Button Content="新建" />
        <Button Content="打开" />
        <Button Content="保存" />
    </ToolBar>
    
    <StatusBar DockPanel.Dock="Bottom">
        <TextBlock>状态栏信息</TextBlock>
    </StatusBar>
    
    <StackPanel DockPanel.Dock="Left" Width="200" Background="LightGray">
        <TextBlock Text="导航菜单" Margin="10" FontWeight="Bold" />
        <Button Content="首页" Margin="10" />
        <Button Content="设置" Margin="10" />
        <Button Content="帮助" Margin="10" />
    </StackPanel>
    
    <Grid Background="White">
        <TextBlock Text="主内容区域" HorizontalAlignment="Center" VerticalAlignment="Center" />
    </Grid>
</DockPanel>
```

Canvas 使用绝对坐标定位元素，适用于需要精确控制元素位置的场景：

```xaml
<Canvas Width="400" Height="300" Background="LightGray">
    <Ellipse Canvas.Left="50" Canvas.Top="50" Width="100" Height="100" Fill="Red" />
    <Rectangle Canvas.Left="200" Canvas.Top="100" Width="120" Height="80" Fill="Blue" />
    <TextBlock Canvas.Left="70" Canvas.Top="90" FontSize="16" Foreground="White">红色圆形</TextBlock>
    <TextBlock Canvas.Left="220" Canvas.Top="130" FontSize="16" Foreground="White">蓝色矩形</TextBlock>
</Canvas>
```

### 3.5 布局最佳实践

1. **使用合适的布局面板**：根据具体需求选择合适的布局面板
2. **优先使用 Grid**：对于复杂布局，Grid 提供了最灵活的控制
3. **避免过度嵌套**：过多的布局嵌套会影响性能
4. **使用 Margin 和 Padding**：合理使用边距和内边距来创建空间
5. **使用 Alignment 属性**：利用 HorizontalAlignment 和 VerticalAlignment 来控制元素的对齐方式
6. **使用 Star 尺寸**：对于需要自适应的行和列，使用 Star 尺寸
7. **考虑响应式设计**：设计能够适应不同窗口大小的布局
8. **使用 Viewbox**：对于需要缩放的内容，使用 Viewbox

## 4. WPF控件详解

### 4.1 常用控件概览

WPF 提供了丰富的内置控件，以下是一些常用的控件：

1. **基础输入控件**：
   - Button：按钮
   - TextBox：文本输入框
   - PasswordBox：密码输入框
   - CheckBox：复选框
   - RadioButton：单选按钮
   - Slider：滑块
   - ComboBox：下拉选择框

2. **显示控件**：
   - TextBlock：文本块
   - Label：标签
   - Image：图片
   - ProgressBar：进度条
   - Calendar：日历
   - DatePicker：日期选择器

3. **列表和表格控件**：
   - ListBox：列表框
   - ComboBox：下拉列表
   - ListView：列表视图
   - DataGrid：数据表格
   - TreeView：树状视图

4. **容器控件**：
   - Grid：网格布局
   - StackPanel：堆叠布局
   - WrapPanel：自动换行布局
   - DockPanel：停靠布局
   - Canvas：画布布局
   - GroupBox：分组框
   - TabControl：选项卡控件

### 4.2 内容控件（ContentControl）

ContentControl 是 WPF 中一个重要的控件基类，它可以包含单个子元素（Content）。常见的 ContentControl 派生类包括：

- Button
- Label
- TextBlock
- CheckBox
- RadioButton
- ScrollViewer
- Window
- UserControl

ContentControl 的使用示例：

```xaml
<Button>
    <StackPanel Orientation="Horizontal">
        <Image Source="icon.png" Width="20" Height="20" />
        <TextBlock Text="带有图标的按钮" Margin="5,0,0,0" />
    </StackPanel>
</Button>

<Label>
    <StackPanel Orientation="Vertical">
        <TextBlock Text="标题" FontSize="16" FontWeight="Bold" />
        <TextBlock Text="副标题" FontSize="12" Foreground="Gray" />
    </StackPanel>
</Label>
```

### 4.3 ItemsControl及其派生类

ItemsControl 是用于显示集合数据的控件基类，它可以包含多个子元素（Items）。常见的 ItemsControl 派生类包括：

- ListBox
- ComboBox
- ListView
- DataGrid
- TreeView
- Menu
- ToolBar

ItemsControl 的使用示例：

```xaml
<!-- 直接添加项目 -->
<ListBox>
    <ListBoxItem>项目 1</ListBoxItem>
    <ListBoxItem>项目 2</ListBoxItem>
    <ListBoxItem>项目 3</ListBoxItem>
</ListBox>

<!-- 绑定集合数据 -->
<ListBox ItemsSource="{Binding Items}" DisplayMemberPath="Name" />

<!-- 使用数据模板 -->
<ListBox ItemsSource="{Binding Items}">
    <ListBox.ItemTemplate>
        <DataTemplate>
            <StackPanel Orientation="Horizontal">
                <Image Source="{Binding Icon}" Width="20" Height="20" />
                <TextBlock Text="{Binding Name}" Margin="5,0,0,0" />
                <TextBlock Text="{Binding Description}" Margin="10,0,0,0" Foreground="Gray" />
            </StackPanel>
        </DataTemplate>
    </ListBox.ItemTemplate>
</ListBox>
```

### 4.4 输入控件与验证

WPF 提供了多种输入控件，同时支持数据验证：

```xaml
<StackPanel Margin="10">
    <TextBox Text="{Binding Name, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}">
        <TextBox.Style>
            <Style TargetType="TextBox">
                <Setter Property="BorderBrush" Value="Gray" />
                <Style.Triggers>
                    <Trigger Property="Validation.HasError" Value="True">
                        <Setter Property="BorderBrush" Value="Red" />
                        <Setter Property="ToolTip" Value="{Binding RelativeSource={RelativeSource Self}, Path=(Validation.Errors)[0].ErrorContent}" />
                    </Trigger>
                </Style.Triggers>
            </Style>
        </TextBox.Style>
    </TextBox>
    
    <PasswordBox Password="{Binding Password, Mode=TwoWay}" Margin="0,10,0,0" />
    
    <CheckBox IsChecked="{Binding RememberMe, Mode=TwoWay}" Content="记住我" Margin="0,10,0,0" />
    
    <Button Content="登录" Command="{Binding LoginCommand}" Margin="0,10,0,0" />
</StackPanel>
```

### 4.5 命令绑定

WPF 的命令系统允许将用户操作与业务逻辑分离：

```xaml
<Button Content="保存" Command="{Binding SaveCommand}" CommandParameter="{Binding SelectedItem}" />

<MenuItem Header="复制" Command="ApplicationCommands.Copy" />
<MenuItem Header="粘贴" Command="ApplicationCommands.Paste" />

<ListBox ItemsSource="{Binding Items}" SelectedItem="{Binding SelectedItem}">
    <ListBox.ItemContainerStyle>
        <Style TargetType="ListBoxItem">
            <Setter Property="Command" Value="{Binding DataContext.ItemCommand, RelativeSource={RelativeSource AncestorType=ListBox}}" />
            <Setter Property="CommandParameter" Value="{Binding}" />
        </Style>
    </ListBox.ItemContainerStyle>
</ListBox>
```

## 5. 数据绑定（Data Binding）

### 5.1 绑定基础

数据绑定是 WPF 的核心特性之一，它允许 UI 元素与数据源自动同步：

```xaml
<!-- 基本数据绑定 -->
<TextBox Text="{Binding Name}" />
<TextBlock Text="{Binding Age}" />
<Button Content="{Binding ButtonText}" Command="{Binding ClickCommand}" />
```

数据绑定的基本概念：
- **源（Source）**：提供数据的对象
- **目标（Target）**：接收数据的 UI 元素
- **路径（Path）**：源对象中数据的路径
- **模式（Mode）**：绑定的方向
- **更新触发器（UpdateSourceTrigger）**：源更新的触发时机

### 5.2 Binding的关键属性

Binding 对象有以下关键属性：

1. **Source**：绑定的数据源
2. **Path**：数据源中属性的路径
3. **Mode**：绑定模式（OneWay、TwoWay、OneWayToSource、OneTime、Default）
4. **UpdateSourceTrigger**：源更新的触发时机（PropertyChanged、LostFocus、Explicit、Default）
5. **Converter**：值转换器
6. **ConverterParameter**：传递给转换器的参数
7. **ConverterCulture**：转换器使用的文化信息
8. **StringFormat**：字符串格式化
9. **TargetNullValue**：目标为空时的值
10. **FallbackValue**：绑定失败时的值
11. **ValidatesOnDataErrors**：是否启用数据错误验证
12. **ValidatesOnExceptions**：是否启用异常验证
13. **NotifyOnValidationError**：是否在验证错误时触发事件

### 5.3 绑定模式（Mode）

| 绑定模式 | 描述 | 适用场景 |
|---------|------|----------|
| OneWay | 从源到目标的单向绑定 | 显示数据，不需要用户修改 |
| TwoWay | 双向绑定，源和目标相互同步 | 编辑表单，需要双向同步 |
| OneWayToSource | 从目标到源的单向绑定 | 仅需要将 UI 值传递给数据源 |
| OneTime | 只绑定一次，后续变化不影响 | 静态数据，不需要更新 |
| Default | 根据目标属性的默认行为 | 大多数情况下的默认选择 |

### 5.4 值转换器（ValueConverter）

值转换器用于在绑定过程中转换数据类型或格式化数据：

```csharp
// 日期转换器示例
public class DateConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is DateTime date)
        {
            return date.ToString("yyyy-MM-dd");
        }
        return string.Empty;
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is string str && DateTime.TryParse(str, out DateTime date))
        {
            return date;
        }
        return DateTime.Now;
    }
}
```

使用值转换器：

```xaml
<Window.Resources>
    <local:DateConverter x:Key="DateConverter" />
</Window.Resources>

<TextBlock Text="{Binding BirthDate, Converter={StaticResource DateConverter}}" />
<TextBox Text="{Binding BirthDate, Converter={StaticResource DateConverter}, Mode=TwoWay}" />
```

### 5.5 集合绑定与ObservableCollection

对于集合数据，WPF 提供了特殊的绑定支持：

```csharp
// 使用 ObservableCollection 实现自动更新
public class ViewModel
{
    public ObservableCollection<Person> People { get; set; }
    
    public ViewModel()
    {
        People = new ObservableCollection<Person>
        {
            new Person { Name = "张三", Age = 25 },
            new Person { Name = "李四", Age = 30 },
            new Person { Name = "王五", Age = 35 }
        };
        
        // 添加项
        People.Add(new Person { Name = "赵六", Age = 40 });
        
        // 删除项
        People.RemoveAt(0);
    }
}
```

绑定到集合：

```xaml
<ListBox ItemsSource="{Binding People}">
    <ListBox.ItemTemplate>
        <DataTemplate>
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="{Binding Name}" Width="100" />
                <TextBlock Text="{Binding Age}" />
            </StackPanel>
        </DataTemplate>
    </ListBox.ItemTemplate>
</ListBox>
```

## 6. MVVM设计模式

### 6.1 MVVM的基本概念

MVVM（Model-View-ViewModel）是一种专门为 WPF 设计的设计模式，它将应用程序分为三个主要部分：

1. **Model**：数据模型，包含业务逻辑和数据访问
2. **View**：视图，用户界面，由 XAML 定义
3. **ViewModel**：视图模型，连接 Model 和 View，包含 UI 逻辑

MVVM 的主要优点：
- 关注点分离：UI 和业务逻辑分离
- 可测试性：ViewModel 可以独立于 View 进行测试
- 可维护性：代码结构清晰，易于维护
- 可重用性：ViewModel 可以在不同的 View 中重用

### 6.2 ViewModel的职责

ViewModel 的主要职责包括：

1. **数据转换**：将 Model 中的数据转换为 View 可以显示的形式
2. **状态管理**：管理 View 的状态
3. **命令处理**：处理用户的交互命令
4. **数据验证**：验证用户输入的数据
5. **导航逻辑**：处理页面或视图之间的导航
6. **服务协调**：协调各种服务的调用

### 6.3 INotifyPropertyChanged接口

INotifyPropertyChanged 接口用于通知 View 数据源的属性值发生了变化：

```csharp
public class Person : INotifyPropertyChanged
{
    private string _name;
    private int _age;
    
    public string Name
    {
        get { return _name; }
        set
        {
            if (_name != value)
            {
                _name = value;
                OnPropertyChanged(nameof(Name));
            }
        }
    }
    
    public int Age
    {
        get { return _age; }
        set
        {
            if (_age != value)
            {
                _age = value;
                OnPropertyChanged(nameof(Age));
            }
        }
    }
    
    public event PropertyChangedEventHandler PropertyChanged;
    
    protected virtual void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
```

### 6.4 命令（ICommand）实现

ICommand 接口用于实现命令模式，将用户操作与业务逻辑分离：

```csharp
public class RelayCommand : ICommand
{
    private readonly Action<object> _execute;
    private readonly Func<object, bool> _canExecute;
    
    public event EventHandler CanExecuteChanged;
    
    public RelayCommand(Action<object> execute, Func<object, bool> canExecute = null)
    {
        _execute = execute;
        _canExecute = canExecute;
    }
    
    public bool CanExecute(object parameter)
    {
        return _canExecute == null || _canExecute(parameter);
    }
    
    public void Execute(object parameter)
    {
        _execute(parameter);
    }
    
    public void RaiseCanExecuteChanged()
    {
        CanExecuteChanged?.Invoke(this, EventArgs.Empty);
    }
}
```

使用 RelayCommand：

```csharp
public class ViewModel
{
    public ICommand SaveCommand { get; set; }
    public ICommand DeleteCommand { get; set; }
    
    public ViewModel()
    {
        SaveCommand = new RelayCommand(Save, CanSave);
        DeleteCommand = new RelayCommand(Delete, CanDelete);
    }
    
    private void Save(object parameter)
    {
        // 保存逻辑
    }
    
    private bool CanSave(object parameter)
    {
        // 检查是否可以保存
        return true;
    }
    
    private void Delete(object parameter)
    {
        // 删除逻辑
    }
    
    private bool CanDelete(object parameter)
    {
        // 检查是否可以删除
        return true;
    }
}
```

### 6.5 MVVM示例

```xaml
<!-- View -->
<Window x:Class="MyWpfApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:MyWpfApp"
        Title="MVVM示例" Height="450" Width="800">
    <Window.DataContext>
        <local:MainViewModel />
    </Window.DataContext>
    
    <Grid>
        <StackPanel Margin="20">
            <TextBlock Text="用户管理" FontSize="20" FontWeight="Bold" Margin="0,0,0,20" />
            
            <ListBox ItemsSource="{Binding Users}" SelectedItem="{Binding SelectedUser}" Margin="0,0,0,20">
                <ListBox.ItemTemplate>
                    <DataTemplate>
                        <StackPanel Orientation="Horizontal">
                            <TextBlock Text="{Binding Name}" Width="100" />
                            <TextBlock Text="{Binding Age}" Width="50" />
                            <TextBlock Text="{Binding Email}" />
                        </StackPanel>
                    </DataTemplate>
                </ListBox.ItemTemplate>
            </ListBox>
            
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="100" />
                    <ColumnDefinition Width="*" />
                </Grid.ColumnDefinitions>
                <Grid.RowDefinitions>
                    <RowDefinition Height="30" />
                    <RowDefinition Height="30" />
                    <RowDefinition Height="30" />
                    <RowDefinition Height="40" />
                </Grid.RowDefinitions>
                
                <TextBlock Text="姓名:" Grid.Column="0" Grid.Row="0" VerticalAlignment="Center" />
                <TextBox Text="{Binding SelectedUser.Name, Mode=TwoWay}" Grid.Column="1" Grid.Row="0" />
                
                <TextBlock Text="年龄:" Grid.Column="0" Grid.Row="1" VerticalAlignment="Center" />
                <TextBox Text="{Binding SelectedUser.Age, Mode=TwoWay}" Grid.Column="1" Grid.Row="1" />
                
                <TextBlock Text="邮箱:" Grid.Column="0" Grid.Row="2" VerticalAlignment="Center" />
                <TextBox Text="{Binding SelectedUser.Email, Mode=TwoWay}" Grid.Column="1" Grid.Row="2" />
                
                <StackPanel Orientation="Horizontal" Grid.Column="0" Grid.Row="3" Grid.ColumnSpan="2" HorizontalAlignment="Right" Margin="0,10,0,0">
                    <Button Content="添加" Command="{Binding AddCommand}" Margin="0,0,10,0" />
                    <Button Content="保存" Command="{Binding SaveCommand}" Margin="0,0,10,0" />
                    <Button Content="删除" Command="{Binding DeleteCommand}" />
                </StackPanel>
            </Grid>
        </StackPanel>
    </Grid>
</Window>
```

```csharp
// Model
public class User : INotifyPropertyChanged
{
    private string _name;
    private int _age;
    private string _email;
    
    public string Name
    {
        get { return _name; }
        set { SetProperty(ref _name, value); }
    }
    
    public int Age
    {
        get { return _age; }
        set { SetProperty(ref _age, value); }
    }
    
    public string Email
    {
        get { return _email; }
        set { SetProperty(ref _email, value); }
    }
    
    public event PropertyChangedEventHandler PropertyChanged;
    
    protected void SetProperty<T>(ref T field, T value, [CallerMemberName] string propertyName = null)
    {
        if (!EqualityComparer<T>.Default.Equals(field, value))
        {
            field = value;
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}

// ViewModel
public class MainViewModel
{
    public ObservableCollection<User> Users { get; set; }
    public User SelectedUser { get; set; }
    
    public ICommand AddCommand { get; set; }
    public ICommand SaveCommand { get; set; }
    public ICommand DeleteCommand { get; set; }
    
    public MainViewModel()
    {
        Users = new ObservableCollection<User>
        {
            new User { Name = "张三", Age = 25, Email = "zhangsan@example.com" },
            new User { Name = "李四", Age = 30, Email = "lisi@example.com" },
            new User { Name = "王五", Age = 35, Email = "wangwu@example.com" }
        };
        
        SelectedUser = Users[0];
        
        AddCommand = new RelayCommand(AddUser);
        SaveCommand = new RelayCommand(SaveUser);
        DeleteCommand = new RelayCommand(DeleteUser);
    }
    
    private void AddUser(object parameter)
    {
        var newUser = new User { Name = "新用户", Age = 0, Email = "" };
        Users.Add(newUser);
        SelectedUser = newUser;
    }
    
    private void SaveUser(object parameter)
    {
        // 保存逻辑
    }
    
    private void DeleteUser(object parameter)
    {
        if (SelectedUser != null)
        {
            Users.Remove(SelectedUser);
            if (Users.Count > 0)
            {
                SelectedUser = Users[0];
            }
            else
            {
                SelectedUser = new User();
            }
        }
    }
}
```

## 7. 样式与模板

### 7.1 样式（Style）基础

样式用于定义控件的外观，避免重复设置相同的属性：

```xaml
<Window.Resources>
    <!-- 基本样式 -->
    <Style x:Key="ButtonStyle" TargetType="Button">
        <Setter Property="Background" Value="Blue" />
        <Setter Property="Foreground" Value="White" />
        <Setter Property="FontSize" Value="14" />
        <Setter Property="Padding" Value="10,5" />
        <Setter Property="Margin" Value="5" />
    </Style>
    
    <!-- 继承样式 -->
    <Style x:Key="PrimaryButtonStyle" TargetType="Button" BasedOn="{StaticResource ButtonStyle}">
        <Setter Property="Background" Value="Green" />
    </Style>
    
    <!-- 隐式样式 -->
    <Style TargetType="TextBlock">
        <Setter Property="FontSize" Value="14" />
        <Setter Property="Margin" Value="5" />
    </Style>
</Window.Resources>

<!-- 使用样式 -->
<Button Content="普通按钮" Style="{StaticResource ButtonStyle}" />
<Button Content="主要按钮" Style="{StaticResource PrimaryButtonStyle}" />
<TextBlock Text="这是一个文本块" />
```

### 7.2 触发器（Trigger）

触发器用于响应属性变化，动态改变控件的外观：

```xaml
<Style TargetType="Button">
    <Setter Property="Background" Value="Blue" />
    <Setter Property="Foreground" Value="White" />
    <Setter Property="Padding" Value="10,5" />
    <Setter Property="Margin" Value="5" />
    
    <Style.Triggers>
        <!-- 属性触发器 -->
        <Trigger Property="IsMouseOver" Value="True">
            <Setter Property="Background" Value="LightBlue" />
            <Setter Property="Cursor" Value="Hand" />
        </Trigger>
        
        <!-- 事件触发器 -->
        <EventTrigger RoutedEvent="MouseDown">
            <BeginStoryboard>
                <Storyboard>
                    <DoubleAnimation Storyboard.TargetProperty="Width" From="100" To="120" Duration="0:0:0.2" />
                </Storyboard>
            </BeginStoryboard>
        </EventTrigger>
        
        <!-- 数据触发器 -->
        <DataTrigger Binding="{Binding IsEnabled}" Value="False">
            <Setter Property="Background" Value="Gray" />
            <Setter Property="Foreground" Value="LightGray" />
        </DataTrigger>
    </Style.Triggers>
</Style>
```

### 7.3 控件模板（ControlTemplate）

控件模板用于完全自定义控件的外观：

```xaml
<ControlTemplate x:Key="CustomButtonTemplate" TargetType="Button">
    <Border x:Name="Border" 
            Background="{TemplateBinding Background}"
            BorderBrush="{TemplateBinding BorderBrush}"
            BorderThickness="{TemplateBinding BorderThickness}"
            CornerRadius="5">
        <StackPanel Orientation="Horizontal" HorizontalAlignment="Center" VerticalAlignment="Center">
            <ContentPresenter x:Name="Content" Margin="{TemplateBinding Padding}" />
        </StackPanel>
    </Border>
    <ControlTemplate.Triggers>
        <Trigger Property="IsMouseOver" Value="True">
            <Setter TargetName="Border" Property="Background" Value="LightBlue" />
        </Trigger>
        <Trigger Property="IsPressed" Value="True">
            <Setter TargetName="Border" Property="Background" Value="DarkBlue" />
            <Setter TargetName="Content" Property="Margin" Value="12,7,8,3" />
        </Trigger>
        <Trigger Property="IsEnabled" Value="False">
            <Setter TargetName="Border" Property="Background" Value="Gray" />
            <Setter TargetName="Border" Property="BorderBrush" Value="LightGray" />
        </Trigger>
    </ControlTemplate.Triggers>
</ControlTemplate>

<Button Content="自定义按钮" Template="{StaticResource CustomButtonTemplate}" Background="Blue" Foreground="White" Padding="10,5" />
```

### 7.4 数据模板（DataTemplate）

数据模板用于定义数据对象的可视化表示：

```xaml
<DataTemplate x:Key="PersonTemplate" DataType="{x:Type local:Person}">
    <Border BorderBrush="Gray" BorderThickness="1" Padding="10" Margin="5" CornerRadius="5">
        <StackPanel>
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="姓名: " FontWeight="Bold" />
                <TextBlock Text="{Binding Name}" />
            </StackPanel>
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="年龄: " FontWeight="Bold" />
                <TextBlock Text="{Binding Age}" />
            </StackPanel>
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="邮箱: " FontWeight="Bold" />
                <TextBlock Text="{Binding Email}" />
            </StackPanel>
        </StackPanel>
    </Border>
</DataTemplate>

<ContentControl Content="{Binding SelectedPerson}" ContentTemplate="{StaticResource PersonTemplate}" />

<ListBox ItemsSource="{Binding People}" ItemTemplate="{StaticResource PersonTemplate}" />
```

### 7.5 资源（Resource）与资源字典

资源字典用于集中管理和共享资源：

```xaml
<!-- Styles.xaml -->
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <SolidColorBrush x:Key="PrimaryColor" Color="Blue" />
    <SolidColorBrush x:Key="SecondaryColor" Color="Green" />
    
    <Style x:Key="ButtonStyle" TargetType="Button">
        <Setter Property="Background" Value="{StaticResource PrimaryColor}" />
        <Setter Property="Foreground" Value="White" />
        <Setter Property="Padding" Value="10,5" />
    </Style>
</ResourceDictionary>

<!-- 在 App.xaml 中引用 -->
<Application.Resources>
    <ResourceDictionary>
        <ResourceDictionary.MergedDictionaries>
            <ResourceDictionary Source="Styles.xaml" />
        </ResourceDictionary.MergedDictionaries>
    </ResourceDictionary>
</Application.Resources>

<!-- 在窗口中引用 -->
<Window.Resources>
    <ResourceDictionary>
        <ResourceDictionary.MergedDictionaries>
            <ResourceDictionary Source="Styles.xaml" />
        </ResourceDictionary.MergedDictionaries>
        
        <!-- 窗口特定资源 -->
        <Style x:Key="WindowButtonStyle" TargetType="Button" BasedOn="{StaticResource ButtonStyle}">
            <Setter Property="Margin" Value="5" />
        </Style>
    </ResourceDictionary>
</Window.Resources>
```

## 8. 动画与图形

### 8.1 动画基础

WPF 提供了强大的动画系统，支持各种类型的动画：

1. **属性动画**：改变控件的属性值
2. **路径动画**：沿着路径移动元素
3. **关键帧动画**：定义多个关键帧，实现更复杂的动画
4. **故事板**：组合多个动画，实现复杂的动画序列

### 8.2 DoubleAnimation与ColorAnimation

DoubleAnimation 用于动画数值类型的属性：

```xaml
<Button Content="动画按钮" Width="100" Height="40">
    <Button.Triggers>
        <EventTrigger RoutedEvent="MouseEnter">
            <BeginStoryboard>
                <Storyboard>
                    <DoubleAnimation Storyboard.TargetProperty="Width" From="100" To="150" Duration="0:0:0.5" />
                    <DoubleAnimation Storyboard.TargetProperty="Height" From="40" To="60" Duration="0:0:0.5" />
                </Storyboard>
            </BeginStoryboard>
        </EventTrigger>
        <EventTrigger RoutedEvent="MouseLeave">
            <BeginStoryboard>
                <Storyboard>
                    <DoubleAnimation Storyboard.TargetProperty="Width" From="150" To="100" Duration="0:0:0.5" />
                    <DoubleAnimation Storyboard.TargetProperty="Height" From="60" To="40" Duration="0:0:0.5" />
                </Storyboard>
            </BeginStoryboard>
        </EventTrigger>
    </Button.Triggers>
</Button>
```

ColorAnimation 用于动画颜色类型的属性：

```xaml
<Rectangle Width="200" Height="100">
    <Rectangle.Fill>
        <SolidColorBrush x:Name="RectBrush" Color="Blue" />
    </Rectangle.Fill>
    <Rectangle.Triggers>
        <EventTrigger RoutedEvent="Loaded">
            <BeginStoryboard>
                <Storyboard RepeatBehavior="Forever" AutoReverse="True">
                    <ColorAnimation Storyboard.TargetName="RectBrush" 
                                   Storyboard.TargetProperty="Color" 
                                   From="Blue" To="Red" 
                                   Duration="0:0:2" />
                </Storyboard>
            </BeginStoryboard>
        </EventTrigger>
    </Rectangle.Triggers>
</Rectangle>
```

### 8.3 Storyboard详解

Storyboard 用于组合和控制多个动画：

```xaml
<Storyboard x:Key="FadeInOutAnimation">
    <DoubleAnimation Storyboard.TargetProperty="Opacity" 
                     From="0" To="1" 
                     Duration="0:0:1" 
                     BeginTime="0:0:0" />
    <DoubleAnimation Storyboard.TargetProperty="Opacity" 
                     From="1" To="0" 
                     Duration="0:0:1" 
                     BeginTime="0:0:2" />
</Storyboard>

<TextBlock Text="淡入淡出动画" Opacity="0">
    <TextBlock.Triggers>
        <EventTrigger RoutedEvent="Loaded">
            <BeginStoryboard Storyboard="{StaticResource FadeInOutAnimation}" RepeatBehavior="Forever" />
        </EventTrigger>
    </TextBlock.Triggers>
</TextBlock>
```

### 8.4 绘图与形状

WPF 提供了丰富的绘图和形状功能：

```xaml
<Canvas Width="400" Height="300" Background="LightGray">
    <!-- 基本形状 -->
    <Rectangle Width="100" Height="100" Fill="Red" Canvas.Left="50" Canvas.Top="50" />
    <Ellipse Width="100" Height="100" Fill="Blue" Canvas.Left="200" Canvas.Top="50" />
    <Line X1="50" Y1="200" X2="150" Y2="250" Stroke="Green" StrokeThickness="2" />
    <Path Data="M 50,200 L 150,200 L 100,150 Z" Fill="Yellow" />
    
    <!-- 复杂路径 -->
    <Path Data="M 200,200 C 250,150 350,150 350,200 S 250,250 200,200" 
          Stroke="Purple" StrokeThickness="2" Fill="Transparent" />
    
    <!-- 文本 -->
    <TextBlock Text="WPF 绘图示例" FontSize="16" FontWeight="Bold" Canvas.Left="100" Canvas.Top="250" />
</Canvas>
```

## 9. 路由事件与命令系统

### 9.1 路由事件的机制

WPF 的路由事件系统允许事件从子元素冒泡到父元素，或从父元素隧道到子元素：

1. **冒泡事件（Bubbling）**：从事件源向上传播到视觉树的根
2. **隧道事件（Tunneling）**：从视觉树的根向下传播到事件源
3. **直接事件（Direct）**：只在事件源上触发，不传播

路由事件的处理：

```csharp
// 处理冒泡事件
private void Button_Click(object sender, RoutedEventArgs e)
{
    // 处理点击事件
    e.Handled = true; // 阻止事件继续传播
}

// 处理隧道事件
private void Grid_PreviewMouseDown(object sender, MouseButtonEventArgs e)
{
    // 处理鼠标按下事件
}
```

### 9.2 冒泡与隧道事件

```xaml
<Grid PreviewMouseDown="Grid_PreviewMouseDown" MouseDown="Grid_MouseDown" Background="LightGray" Padding="20">
    <StackPanel PreviewMouseDown="StackPanel_PreviewMouseDown" MouseDown="StackPanel_MouseDown" Background="LightBlue" Padding="10">
        <Button Content="点击我" PreviewMouseDown="Button_PreviewMouseDown" Click="Button_Click" />
    </StackPanel>
</Grid>
```

事件触发顺序：
1. Grid.PreviewMouseDown（隧道）
2. StackPanel.PreviewMouseDown（隧道）
3. Button.PreviewMouseDown（隧道）
4. Button.Click（直接）
5. Button.MouseDown（冒泡）
6. StackPanel.MouseDown（冒泡）
7. Grid.MouseDown（冒泡）

### 9.3 命令（Command）机制

WPF 的命令系统提供了一种将用户操作与业务逻辑分离的方式：

1. **命令源（Command Source）**：触发命令的元素，如 Button、MenuItem
2. **命令目标（Command Target）**：命令的执行目标，如 TextBox
3. **命令绑定（Command Binding）**：将命令与处理方法关联
4. **命令（Command）**：表示要执行的操作，如 ApplicationCommands.Copy

```xaml
<Window.CommandBindings>
    <CommandBinding Command="ApplicationCommands.Open" 
                    Executed="OpenCommand_Executed" 
                    CanExecute="OpenCommand_CanExecute" />
    <CommandBinding Command="ApplicationCommands.Save" 
                    Executed="SaveCommand_Executed" 
                    CanExecute="SaveCommand_CanExecute" />
</Window.CommandBindings>

<StackPanel>
    <MenuItem Header="文件">
        <MenuItem Header="打开" Command="ApplicationCommands.Open" />
        <MenuItem Header="保存" Command="ApplicationCommands.Save" />
    </MenuItem>
    <Button Content="打开" Command="ApplicationCommands.Open" />
    <Button Content="保存" Command="ApplicationCommands.Save" />
</StackPanel>
```

```csharp
private void OpenCommand_Executed(object sender, ExecutedRoutedEventArgs e)
{
    // 执行打开操作
}

private void OpenCommand_CanExecute(object sender, CanExecuteRoutedEventArgs e)
{
    e.CanExecute = true; // 检查是否可以执行
}

private void SaveCommand_Executed(object sender, ExecutedRoutedEventArgs e)
{
    // 执行保存操作
}

private void SaveCommand_CanExecute(object sender, CanExecuteRoutedEventArgs e)
{
    e.CanExecute = true; // 检查是否可以执行
}
```

### 9.4 自定义命令

除了使用内置命令，还可以创建自定义命令：

```csharp
public static class CustomCommands
{
    public static readonly RoutedUICommand Exit = new RoutedUICommand(
        "退出", "Exit", typeof(CustomCommands),
        new InputGestureCollection { new KeyGesture(Key.F4, ModifierKeys.Alt) });
    
    public static readonly RoutedUICommand About = new RoutedUICommand(
        "关于", "About", typeof(CustomCommands));
}
```

```xaml
<Window.CommandBindings>
    <CommandBinding Command="local:CustomCommands.Exit" 
                    Executed="ExitCommand_Executed" 
                    CanExecute="ExitCommand_CanExecute" />
    <CommandBinding Command="local:CustomCommands.About" 
                    Executed="AboutCommand_Executed" 
                    CanExecute="AboutCommand_CanExecute" />
</Window.CommandBindings>

<MenuItem Header="帮助">
    <MenuItem Header="关于" Command="local:CustomCommands.About" />
    <Separator />
    <MenuItem Header="退出" Command="local:CustomCommands.Exit" />
</MenuItem>
```

## 10. WPF性能优化与最佳实践

### 10.1 资源管理优化

1. **合理使用资源字典**：将资源集中管理，避免重复定义
2. **使用静态资源**：对于不会变化的资源，使用 StaticResource
3. **延迟加载资源**：对于大型资源，使用延迟加载
4. **释放未使用的资源**：及时释放不再使用的资源
5. **避免内存泄漏**：正确处理事件订阅和资源引用

### 10.2 虚拟化与延迟加载

1. **列表虚拟化**：对于大量数据的列表，使用虚拟化
   ```xaml
   <ListBox ItemsSource="{Binding Items}"
            VirtualizingStackPanel.IsVirtualizing="True"
            VirtualizingStackPanel.VirtualizationMode="Recycling" />
   ```

2. **数据虚拟化**：对于非常大的数据集，使用数据虚拟化
3. **延迟加载**：对于复杂的 UI 元素，使用延迟加载
   ```xaml
   <ContentControl Content="{Binding ComplexContent}" IsAsync="True" />
   ```

### 10.3 绑定性能优化

1. **使用合适的绑定模式**：根据需要选择合适的绑定模式
2. **优化绑定路径**：避免深层嵌套的绑定路径
3. **使用 OneWay 绑定**：对于不需要双向绑定的场景，使用 OneWay 绑定
4. **使用 ObservableCollection**：对于动态集合，使用 ObservableCollection
5. **避免不必要的绑定更新**：合理设置 UpdateSourceTrigger

### 10.4 UI线程与异步操作

1. **使用异步操作**：对于耗时操作，使用异步处理
   ```csharp
   private async void LoadDataButton_Click(object sender, RoutedEventArgs e)
   {
       IsBusy = true;
       try
       {
           await Task.Run(() => LoadData());
       }
       finally
       {
           IsBusy = false;
       }
   }
   ```

2. **使用 Dispatcher**：在非 UI 线程中更新 UI 时，使用 Dispatcher
   ```csharp
   private void BackgroundOperation()
   {
       // 执行后台操作
       
       // 更新 UI
       Application.Current.Dispatcher.Invoke(() =>
       {
           StatusText = "操作完成";
       });
   }
   ```

3. **避免阻塞 UI 线程**：不要在 UI 线程中执行耗时操作
4. **使用进度报告**：对于长时间运行的操作，使用进度报告

### 10.5 性能监控与调试

1. **使用性能分析工具**：
   - Visual Studio 性能分析器
   - WPF 性能工具（PerfView）
   - Snoop（WPF UI 调试工具）

2. **监控视觉树复杂度**：避免过度复杂的视觉树
3. **监控绑定更新**：避免不必要的绑定更新
4. **使用日志**：记录性能关键路径的执行时间
5. **定期测试**：定期进行性能测试，发现问题及时优化

## 11. 总结

WPF 是一个功能强大、灵活多变的用户界面框架，它提供了丰富的功能和工具，使得开发者可以创建高质量、现代化的 Windows 应用程序。通过本文的学习，您应该已经掌握了 WPF 的核心概念和基本技能，包括：

1. **WPF 概述**：了解了 WPF 的基本概念、体系结构和与 WinForms 的区别
2. **XAML 基础**：掌握了 XAML 的语法和基本用法
3. **布局系统**：学会了使用各种布局面板创建复杂的 UI 布局
4. **控件详解**：熟悉了常用控件的使用方法和特性
5. **数据绑定**：掌握了 WPF 的数据绑定机制
6. **MVVM 模式**：理解了 MVVM 设计模式的基本概念和实践方法
7. **样式与模板**：学会了使用样式和模板自定义控件的外观
8. **动画与图形**：掌握了 WPF 的动画和绘图功能
9. **路由事件与命令系统**：理解了 WPF 的事件和命令系统
10. **性能优化**：了解了 WPF 应用程序的性能优化方法

WPF 的学习曲线可能相对陡峭，但一旦掌握，您将能够创建出美观、高效、可维护的 Windows 桌面应用程序。随着 .NET 的不断发展，WPF 也在不断演进，为开发者提供更多的功能和更好的性能。

希望本文能够帮助您快速入门 WPF 开发，并在实践中不断提升自己的技能。祝您开发愉快！

## 参考资料

- [Microsoft WPF 文档](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/)
- [WPF 教程](https://wpf-tutorial.com/)
- [MVVM 模式](https://docs.microsoft.com/en-us/archive/msdn-magazine/2009/february/patterns-wpf-apps-with-the-model-view-viewmodel-design-pattern)
- [WPF 性能优化](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/optimizing-wpf-application-performance)
- [WPF 数据绑定](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/data/)
- [WPF 样式和模板](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/controls/styles-and-templates-overview)
- [WPF 动画](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/graphics-multimedia/animation-overview)
- [WPF 命令](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/commanding-overview)