---
layout: post
title:  "WPF学习指南 - 2026"
date:   2026-01-23 10:00:00 +0800
categories: C# WPF Windows
---

# WPF学习指南 - 2026

## 目录

- [1. WPF概述](#1-wpf概述)
- [2. XAML基础](#2-xaml基础)
- [3. WPF布局系统](#3-wpf布局系统)
- [4. WPF控件详解](#4-wpf控件详解)
- [5. 数据绑定（Data Binding）](#5-数据绑定data-binding)
- [6. MVVM设计模式](#6-mvvm设计模式)
- [7. 样式与模板](#7-样式与模板)
- [8. 动画与图形](#8-动画与图形)
- [9. 路由事件与命令系统](#9-路由事件与命令系统)
- [10. WPF性能优化与最佳实践](#10-wpf性能优化与最佳实践)
- [11. 总结](#11-总结)
- [参考资料](#参考资料)
- [12. 依赖属性（DependencyProperty）深入](#12-依赖属性dependencyproperty深入)
- [13. 路由事件与命令高级用法](#13-路由事件与命令高级用法)
- [14. 自定义控件、用户控件与行为](#14-自定义控件用户控件与行为)
- [15. 主题、皮肤与资源组织](#15-主题皮肤与资源组织)
- [16. 本地化与多语言（Localization / Globalization）](#16-本地化与多语言localization--globalization)
- [17. MVVM 框架与依赖注入](#17-mvvm-框架与依赖注入)
- [18. 调试 WPF 与常见工具](#18-调试-wpf-与常见工具)
- [19. 常见问题与排查清单](#19-常见问题与排查清单)
- [20. 实战项目结构示例（中小型业务系统）](#20-实战项目结构示例中小型业务系统)
- [21. 文档生成、打印与报表](#21-文档生成打印与报表)
- [22. WPF 3D（视图、模型与相机）](#22-wpf-3d视图模型与相机)
- [23. Win32 / WinForms 互操作](#23-win32--winforms-互操作)
- [24. 部署、更新与配置管理](#24-部署更新与配置管理)
- [25. 无障碍（Accessibility）与键盘导航](#25-无障碍accessibility与键盘导航)
- [26. UI 自动化测试简述](#26-ui-自动化测试简述)
- [27. 小结与下一步进阶方向](#27-小结与下一步进阶方向)

## 1. WPF概述

### 1.1 什么是WPF

Windows Presentation Foundation (WPF) 是微软推出的基于 .NET Framework 的用户界面框架，用于创建 Windows 桌面应用程序。WPF 提供了丰富的图形、动画和交互功能，支持数据绑定、样式、模板等现代 UI 开发特性，是构建现代化 Windows 应用程序的理想选择。

WPF 于 2006 年随 .NET Framework 3.0 一起发布，旨在替代传统的 Windows Forms 技术，提供更现代、更灵活的 UI 开发体验。

### 1.2 WPF的体系结构

WPF 的体系结构由以下几个主要部分组成：

1. **表示子系统**：负责渲染和显示 UI 元素，包括：
   - DirectX 渲染引擎：使用 DirectX 进行硬件加速渲染
   - 媒体集成：支持音频、视频和 3D 内容
   - 文本渲染：基于 ClearType 技术的高质量文本渲染

2. **内容呈现系统**：定义 UI 元素的结构和行为，包括：
   - 视觉树（Visual Tree）：表示 UI 的实际渲染结构
   - 逻辑树（Logical Tree）：表示应用程序定义的 UI 结构
   - 元素树（Element Tree）：逻辑树的扩展，包含更多的布局信息

3. **应用程序模型**：提供应用程序的生命周期管理，包括：
   - 应用程序启动和关闭
   - 窗口管理
   - 导航系统

4. **核心服务**：提供各种支持功能，包括：
   - 数据绑定
   - 样式和模板
   - 资源系统
   - 命令系统
   - 事件系统

### 1.3 WPF与WinForms的区别

| 特性 | WPF | WinForms |
|------|-----|----------|
| 渲染引擎 | DirectX 硬件加速 | GDI+ 软件渲染 |
| UI 定义 | XAML（声明式） | 代码（命令式） |
| 布局系统 | 灵活的布局面板（Grid、StackPanel等） | 固定位置和大小 |
| 数据绑定 | 强大的双向数据绑定 | 有限的数据绑定能力 |
| 样式和模板 | 丰富的样式和模板系统 | 有限的样式支持 |
| 动画支持 | 内置动画系统 | 需要第三方库或自定义实现 |
| 3D 支持 | 内置 3D 渲染能力 | 不支持 |
| 分辨率独立性 | 基于设备无关单位 | 基于像素 |
| 学习曲线 | 较陡峭 | 较平缓 |

## 2. XAML基础

### 2.1 XAML简介

XAML（Extensible Application Markup Language）是一种声明式标记语言，用于定义 WPF 应用程序的用户界面。XAML 基于 XML，提供了一种简洁、直观的方式来创建和布局 UI 元素。

XAML 的主要优点：
- 声明式语法，使 UI 定义更加清晰
- 与代码分离，提高代码的可维护性
- 工具支持良好，Visual Studio 和 Blend 都提供了可视化编辑功能
- 支持复杂的对象初始化和属性设置

### 2.2 XAML元素与属性

XAML 中的每个元素对应一个 .NET 类，属性对应类的属性。例如：

```xaml
<!-- 元素 = 类，属性 = 类的属性 -->
<Button Content="Click Me" Width="100" Height="30" />

<!-- 等同于 C# 代码 -->
// Button button = new Button();
// button.Content = "Click Me";
// button.Width = 100;
// button.Height = 30;
```

XAML 元素可以包含子元素，这对应于对象的组合关系：

```xaml
<Grid>
    <Button Content="Click Me" />
</Grid>

<!-- 等同于 C# 代码 -->
// Grid grid = new Grid();
// Button button = new Button();
// button.Content = "Click Me";
// grid.Children.Add(button);
```

### 2.3 对象与属性初始化

XAML 提供了多种方式来初始化对象和设置属性：

1. **属性语法**：使用属性名和值的方式设置属性
   ```xaml
   <Button Width="100" Height="30" />
   ```

2. **元素语法**：使用子元素的方式设置属性
   ```xaml
   <Button>
       <Button.Width>100</Button.Width>
       <Button.Height>30</Button.Height>
   </Button>
   ```

3. **内容语法**：对于只有一个内容属性的元素，可以直接设置内容
   ```xaml
   <Button>Click Me</Button>
   ```

4. **集合语法**：对于集合类型的属性，可以使用子元素添加集合项
   ```xaml
   <Grid>
       <Grid.ColumnDefinitions>
           <ColumnDefinition Width="*" />
           <ColumnDefinition Width="*" />
       </Grid.ColumnDefinitions>
   </Grid>
   ```

5. **标记扩展**：使用特殊的语法来引用其他对象或执行特殊操作
   ```xaml
   <Button Content="{Binding ButtonText}" />
   ```

### 2.4 XAML命名空间

XAML 文件中的命名空间定义了可用的元素和类型：

```xaml
<Window x:Class="MyWpfApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:MyWpfApp"
        Title="MainWindow" Height="450" Width="800">
    <!-- 内容 -->
</Window>
```

- `xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`：WPF 核心命名空间，包含所有 UI 元素
- `xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`：XAML 语言命名空间，包含 XAML 特定的功能
- `xmlns:local="clr-namespace:MyWpfApp"`：本地命名空间，引用当前项目中的类型

## 3. WPF布局系统

### 3.1 布局面板概览

WPF 提供了多种布局面板，用于组织和排列 UI 元素：

| 布局面板 | 描述 | 适用场景 |
|---------|------|----------|
| Grid | 网格布局，支持行列划分 | 复杂布局，需要精确定位 |
| StackPanel | 堆叠布局，水平或垂直排列 | 简单的线性排列 |
| WrapPanel | 自动换行的堆叠布局 | 动态数量的元素排列 |
| DockPanel | 停靠布局，元素可以停靠在边缘 | 工具栏、状态栏等 |
| Canvas | 画布布局，使用绝对坐标定位 | 自定义绘图、游戏界面 |
| UniformGrid | 均匀网格布局，所有单元格大小相同 | 图标网格、棋盘等 |
| Viewbox | 自动缩放内容以适应容器 | 需要自适应大小的内容 |

### 3.2 Grid布局

Grid 是最常用的布局面板，它允许通过定义行和列来创建复杂的布局：

```xaml
<Grid>
    <!-- 定义列 -->
    <Grid.ColumnDefinitions>
        <ColumnDefinition Width="100" /> <!-- 固定宽度 -->
        <ColumnDefinition Width="*" /> <!-- 自适应宽度 -->
        <ColumnDefinition Width="2*" /> <!-- 自适应宽度，是前一列的两倍 -->
    </Grid.ColumnDefinitions>
    
    <!-- 定义行 -->
    <Grid.RowDefinitions>
        <RowDefinition Height="50" /> <!-- 固定高度 -->
        <RowDefinition Height="*" /> <!-- 自适应高度 -->
        <RowDefinition Height="40" /> <!-- 固定高度 -->
    </Grid.RowDefinitions>
    
    <!-- 放置控件 -->
    <Label Content="用户名:" Grid.Column="0" Grid.Row="0" VerticalAlignment="Center" />
    <TextBox Grid.Column="1" Grid.Row="0" Grid.ColumnSpan="2" Margin="5" />
    
    <Label Content="密码:" Grid.Column="0" Grid.Row="1" VerticalAlignment="Top" Margin="0,5,0,0" />
    <PasswordBox Grid.Column="1" Grid.Row="1" Grid.ColumnSpan="2" Margin="5" />
    
    <Button Content="登录" Grid.Column="1" Grid.Row="2" HorizontalAlignment="Right" Margin="5" />
    <Button Content="取消" Grid.Column="2" Grid.Row="2" HorizontalAlignment="Left" Margin="5" />
</Grid>
```

### 3.3 StackPanel与WrapPanel

StackPanel 用于创建简单的线性布局，元素可以水平或垂直排列：

```xaml
<!-- 垂直排列 -->
<StackPanel Orientation="Vertical" Margin="10" Padding="10" Background="LightGray">
    <TextBlock Text="个人信息" FontSize="16" FontWeight="Bold" Margin="0,0,0,10" />
    <StackPanel Orientation="Horizontal" Margin="0,5,0,5">
        <TextBlock Text="姓名:" Width="80" VerticalAlignment="Center" />
        <TextBox Width="200" />
    </StackPanel>
    <StackPanel Orientation="Horizontal" Margin="0,5,0,5">
        <TextBlock Text="年龄:" Width="80" VerticalAlignment="Center" />
        <TextBox Width="200" />
    </StackPanel>
    <StackPanel Orientation="Horizontal" Margin="0,10,0,0" HorizontalAlignment="Right">
        <Button Content="保存" Margin="0,0,10,0" />
        <Button Content="取消" />
    </StackPanel>
</StackPanel>
```

WrapPanel 类似于 StackPanel，但当元素超出容器边界时会自动换行：

```xaml
<WrapPanel Orientation="Horizontal" Margin="10" Padding="10" Background="LightGray">
    <Button Content="按钮 1" Margin="5" Width="100" />
    <Button Content="按钮 2" Margin="5" Width="100" />
    <Button Content="按钮 3" Margin="5" Width="100" />
    <Button Content="按钮 4" Margin="5" Width="100" />
    <Button Content="按钮 5" Margin="5" Width="100" />
    <Button Content="按钮 6" Margin="5" Width="100" />
</WrapPanel>
```

### 3.4 DockPanel与Canvas

DockPanel 允许元素停靠在容器的边缘：

```xaml
<DockPanel LastChildFill="True">
    <Menu DockPanel.Dock="Top">
        <MenuItem Header="文件">
            <MenuItem Header="新建" />
            <MenuItem Header="打开" />
            <MenuItem Header="保存" />
        </MenuItem>
        <MenuItem Header="编辑">
            <MenuItem Header="复制" />
            <MenuItem Header="粘贴" />
        </MenuItem>
    </Menu>
    
    <ToolBar DockPanel.Dock="Top">
        <Button Content="新建" />
        <Button Content="打开" />
        <Button Content="保存" />
    </ToolBar>
    
    <StatusBar DockPanel.Dock="Bottom">
        <TextBlock>状态栏信息</TextBlock>
    </StatusBar>
    
    <StackPanel DockPanel.Dock="Left" Width="200" Background="LightGray">
        <TextBlock Text="导航菜单" Margin="10" FontWeight="Bold" />
        <Button Content="首页" Margin="10" />
        <Button Content="设置" Margin="10" />
        <Button Content="帮助" Margin="10" />
    </StackPanel>
    
    <Grid Background="White">
        <TextBlock Text="主内容区域" HorizontalAlignment="Center" VerticalAlignment="Center" />
    </Grid>
</DockPanel>
```

Canvas 使用绝对坐标定位元素，适用于需要精确控制元素位置的场景：

```xaml
<Canvas Width="400" Height="300" Background="LightGray">
    <Ellipse Canvas.Left="50" Canvas.Top="50" Width="100" Height="100" Fill="Red" />
    <Rectangle Canvas.Left="200" Canvas.Top="100" Width="120" Height="80" Fill="Blue" />
    <TextBlock Canvas.Left="70" Canvas.Top="90" FontSize="16" Foreground="White">红色圆形</TextBlock>
    <TextBlock Canvas.Left="220" Canvas.Top="130" FontSize="16" Foreground="White">蓝色矩形</TextBlock>
</Canvas>
```

### 3.5 布局最佳实践

1. **使用合适的布局面板**：根据具体需求选择合适的布局面板
2. **优先使用 Grid**：对于复杂布局，Grid 提供了最灵活的控制
3. **避免过度嵌套**：过多的布局嵌套会影响性能
4. **使用 Margin 和 Padding**：合理使用边距和内边距来创建空间
5. **使用 Alignment 属性**：利用 HorizontalAlignment 和 VerticalAlignment 来控制元素的对齐方式
6. **使用 Star 尺寸**：对于需要自适应的行和列，使用 Star 尺寸
7. **考虑响应式设计**：设计能够适应不同窗口大小的布局
8. **使用 Viewbox**：对于需要缩放的内容，使用 Viewbox

### 3.6 布局相关附加属性总览（Attached Properties）

布局面板大量依赖“附加属性（Attached Property）”来描述子元素在布局中的行为。这些属性看似是子控件的属性，实际上由父布局面板定义。

1. **Grid 相关附加属性**
   - `Grid.Row`：子元素所在的行索引（从 0 开始）
   - `Grid.Column`：子元素所在的列索引（从 0 开始）
   - `Grid.RowSpan`：子元素跨越的行数
   - `Grid.ColumnSpan`：子元素跨越的列数
   - `Grid.IsSharedSizeScope`：用在父级 Grid 上，使多个 Grid 之间共享列宽
   - `Grid.ShowGridLines`：调试时常用，显示网格线（一般仅在开发阶段打开）

2. **DockPanel 相关附加属性**
   - `DockPanel.Dock`：取值 `Left`、`Top`、`Right`、`Bottom`
   - `LastChildFill`：DockPanel 自身的属性，最后一个子元素是否填充剩余空间

3. **Canvas 相关附加属性**
   - `Canvas.Left`：相对 Canvas 左边的偏移
   - `Canvas.Top`：相对 Canvas 顶部的偏移
   - `Canvas.Right`：相对 Canvas 右边的偏移（较少使用）
   - `Canvas.Bottom`：相对 Canvas 底部的偏移（较少使用）

4. **其他常见布局附加属性**
   - `ScrollViewer.HorizontalScrollBarVisibility`：指定水平滚动条显示策略（Disabled、Auto、Hidden、Visible）
   - `ScrollViewer.VerticalScrollBarVisibility`：指定垂直滚动条显示策略
   - `DockPanel.Dock`：控制元素在 DockPanel 中停靠的位置
   - `Viewbox.Stretch`：拉伸方式（None、Fill、Uniform、UniformToFill）
   - `Viewbox.StretchDirection`：拉伸方向（UpOnly、DownOnly、Both）

综合示例：

```xaml
<Grid ShowGridLines="True" Grid.IsSharedSizeScope="True">
    <Grid.ColumnDefinitions>
        <ColumnDefinition Width="Auto" SharedSizeGroup="LabelColumn" />
        <ColumnDefinition Width="*" />
    </Grid.ColumnDefinitions>

    <TextBlock Text="姓名:" Grid.Row="0" Grid.Column="0" Margin="5" />
    <TextBox Grid.Row="0" Grid.Column="1" Margin="5" />

    <TextBlock Text="年龄:" Grid.Row="1" Grid.Column="0" Margin="5" />
    <TextBox Grid.Row="1" Grid.Column="1" Margin="5" />
</Grid>
```

### 3.7 常用布局对比清单

下表从“尺寸计算”“子元素对齐”“典型属性”等角度对常用布局进行总结，便于快速选择：

| 面板 | 子元素定位方式 | 尺寸计算特点 | 典型属性 |
|------|----------------|--------------|----------|
| Grid | 行列+附加属性 | 先计算行列尺寸，再放置子元素 | `RowDefinitions`、`ColumnDefinitions`、`Grid.Row`、`Grid.Column` |
| StackPanel | 顺序堆叠 | 先计算布局方向上的总尺寸，再测量另一方向最大值 | `Orientation` |
| WrapPanel | 堆叠且自动换行 | 行满后换行，每行高度取该行最大元素高度 | `ItemWidth`、`ItemHeight`、`Orientation` |
| DockPanel | 边缘停靠 | 按顺序将子元素停靠到四边，最后子元素可填充剩余空间 | `DockPanel.Dock`、`LastChildFill` |
| Canvas | 绝对坐标 | 不参与复杂布局，仅根据坐标放置 | `Canvas.Left`、`Canvas.Top` |
| UniformGrid | 均匀网格 | 所有单元格大小一致 | `Rows`、`Columns`、`FirstColumn` |
| Viewbox | 缩放内容 | 按比例缩放内部内容以适配自身大小 | `Stretch`、`StretchDirection` |

实际项目中一般遵循：**整体用 Grid 构架、局部用 StackPanel/WrapPanel 组织、特定区域用 DockPanel 或 Canvas 实现特殊效果**。

## 4. WPF控件详解

### 4.1 常用控件概览

WPF 提供了丰富的内置控件，以下是一些常用的控件：

1. **基础输入控件**：
   - Button：按钮
   - TextBox：文本输入框
   - PasswordBox：密码输入框
   - CheckBox：复选框
   - RadioButton：单选按钮
   - Slider：滑块
   - ComboBox：下拉选择框

2. **显示控件**：
   - TextBlock：文本块
   - Label：标签
   - Image：图片
   - ProgressBar：进度条
   - Calendar：日历
   - DatePicker：日期选择器

3. **列表和表格控件**：
   - ListBox：列表框
   - ComboBox：下拉列表
   - ListView：列表视图
   - DataGrid：数据表格
   - TreeView：树状视图

4. **容器控件**：
   - Grid：网格布局
   - StackPanel：堆叠布局
   - WrapPanel：自动换行布局
   - DockPanel：停靠布局
   - Canvas：画布布局
   - GroupBox：分组框
   - TabControl：选项卡控件

### 4.2 内容控件（ContentControl）

ContentControl 是 WPF 中一个重要的控件基类，它可以包含单个子元素（Content）。常见的 ContentControl 派生类包括：

- Button
- Label
- TextBlock
- CheckBox
- RadioButton
- ScrollViewer
- Window
- UserControl

ContentControl 的使用示例：

```xaml
<Button>
    <StackPanel Orientation="Horizontal">
        <Image Source="icon.png" Width="20" Height="20" />
        <TextBlock Text="带有图标的按钮" Margin="5,0,0,0" />
    </StackPanel>
</Button>

<Label>
    <StackPanel Orientation="Vertical">
        <TextBlock Text="标题" FontSize="16" FontWeight="Bold" />
        <TextBlock Text="副标题" FontSize="12" Foreground="Gray" />
    </StackPanel>
</Label>
```

### 4.3 ItemsControl及其派生类

ItemsControl 是用于显示集合数据的控件基类，它可以包含多个子元素（Items）。常见的 ItemsControl 派生类包括：

- ListBox
- ComboBox
- ListView
- DataGrid
- TreeView
- Menu
- ToolBar

ItemsControl 的使用示例：

```xaml
<!-- 直接添加项目 -->
<ListBox>
    <ListBoxItem>项目 1</ListBoxItem>
    <ListBoxItem>项目 2</ListBoxItem>
    <ListBoxItem>项目 3</ListBoxItem>
</ListBox>

<!-- 绑定集合数据 -->
<ListBox ItemsSource="{Binding Items}" DisplayMemberPath="Name" />

<!-- 使用数据模板 -->
<ListBox ItemsSource="{Binding Items}">
    <ListBox.ItemTemplate>
        <DataTemplate>
            <StackPanel Orientation="Horizontal">
                <Image Source="{Binding Icon}" Width="20" Height="20" />
                <TextBlock Text="{Binding Name}" Margin="5,0,0,0" />
                <TextBlock Text="{Binding Description}" Margin="10,0,0,0" Foreground="Gray" />
            </StackPanel>
        </DataTemplate>
    </ListBox.ItemTemplate>
</ListBox>
```

### 4.4 输入控件与验证

WPF 提供了多种输入控件，同时支持数据验证：

```xaml
<StackPanel Margin="10">
    <TextBox Text="{Binding Name, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}">
        <TextBox.Style>
            <Style TargetType="TextBox">
                <Setter Property="BorderBrush" Value="Gray" />
                <Style.Triggers>
                    <Trigger Property="Validation.HasError" Value="True">
                        <Setter Property="BorderBrush" Value="Red" />
                        <Setter Property="ToolTip" Value="{Binding RelativeSource={RelativeSource Self}, Path=(Validation.Errors)[0].ErrorContent}" />
                    </Trigger>
                </Style.Triggers>
            </Style>
        </TextBox.Style>
    </TextBox>
    
    <PasswordBox Password="{Binding Password, Mode=TwoWay}" Margin="0,10,0,0" />
    
    <CheckBox IsChecked="{Binding RememberMe, Mode=TwoWay}" Content="记住我" Margin="0,10,0,0" />
    
    <Button Content="登录" Command="{Binding LoginCommand}" Margin="0,10,0,0" />
</StackPanel>
```

### 4.5 命令绑定

WPF 的命令系统允许将用户操作与业务逻辑分离：

```xaml
<Button Content="保存" Command="{Binding SaveCommand}" CommandParameter="{Binding SelectedItem}" />

<MenuItem Header="复制" Command="ApplicationCommands.Copy" />
<MenuItem Header="粘贴" Command="ApplicationCommands.Paste" />

<ListBox ItemsSource="{Binding Items}" SelectedItem="{Binding SelectedItem}">
    <ListBox.ItemContainerStyle>
        <Style TargetType="ListBoxItem">
            <Setter Property="Command" Value="{Binding DataContext.ItemCommand, RelativeSource={RelativeSource AncestorType=ListBox}}" />
            <Setter Property="CommandParameter" Value="{Binding}" />
        </Style>
    </ListBox.ItemContainerStyle>
</ListBox>
```

### 4.6 控件继承层次与通用属性总表

大多数控件都继承自几个核心基类，这些基类上的属性和事件是“所有控件通用的基础知识”。理解这些基类，比死记每个控件所有属性更高效。

1. **DependencyObject / UIElement / FrameworkElement**
   - 常用依赖属性（大多在 `FrameworkElement`）：
     - `Width` / `Height` / `MinWidth` / `MinHeight` / `MaxWidth` / `MaxHeight`
     - `Margin` / `Padding`（注意：Padding 从 `Control` 开始才有）
     - `HorizontalAlignment` / `VerticalAlignment`
     - `Visibility`：Visible / Hidden / Collapsed
     - `DataContext`：数据绑定的入口
     - `Style` / `Resources`：样式与资源
     - `ToolTip`：提示信息（可绑定任意对象）
   - 常用事件：
     - 鼠标：`MouseDown` / `MouseUp` / `MouseMove` / `MouseEnter` / `MouseLeave` 等
     - 键盘：`KeyDown` / `KeyUp`
     - 布局：`Loaded` / `SizeChanged` / `LayoutUpdated`

2. **Control（大多数交互控件的基类）**
   - 视觉相关属性：
     - `Foreground` / `Background`
     - `FontFamily` / `FontSize` / `FontWeight` / `FontStyle` / `TextDecorations`
     - `BorderBrush` / `BorderThickness`
     - `Padding`
     - `Cursor`：鼠标指针样式
   - 交互状态：
     - `IsEnabled`：是否可交互
     - `IsHitTestVisible`：是否参与命中测试
     - `TabIndex` / `IsTabStop`：键盘导航顺序
   - 模板相关：
     - `Template`：`ControlTemplate`
     - `OverridesDefaultStyle`：是否忽略默认样式
     - `FocusVisualStyle`：键盘焦点时的虚线框样式

3. **ContentControl（Button、Label、GroupBox、UserControl、Window 等）**
   - 关键属性：
     - `Content`：单个内容对象（可以是任意 XAML 元素或字符串）
     - `ContentTemplate`：`DataTemplate`，定义 Content 的展示方式
     - `ContentTemplateSelector`：用于根据数据动态选择模板
     - `ContentStringFormat`：内容转为字符串的格式

4. **ItemsControl（ListBox、ListView、ComboBox、TreeView、Menu 等）**
   - 关键属性：
     - `ItemsSource`：集合数据源
     - `Items`：手动添加的项集合
     - `ItemTemplate`：每一项的 `DataTemplate`
     - `ItemTemplateSelector`：动态选择模板
     - `ItemContainerStyle`：Item 容器（如 `ListBoxItem`）的样式
     - `ItemsPanel`：`ItemsPanelTemplate`，内部使用的布局面板
   - 与选择相关（来自 `Selector` 基类，如 ListBox、ComboBox 等）：
     - `SelectedItem` / `SelectedIndex` / `SelectedValue`
     - `SelectedValuePath`
     - `IsSynchronizedWithCurrentItem`：是否与集合的 CurrentItem 同步

5. **文本输入控件（TextBoxBase / TextBox / RichTextBox）**
   - TextBox 常用属性：
     - `Text`：文本内容
     - `AcceptsReturn`：是否接受回车（多行输入）
     - `AcceptsTab`：是否接受 Tab
     - `MaxLength`：最大长度
     - `IsReadOnly`：只读
     - `CharacterCasing`：大小写（Normal、Upper、Lower）
     - `TextWrapping`：自动换行（NoWrap、Wrap、WrapWithOverflow）
     - `SelectionStart` / `SelectionLength` / `SelectedText`

6. **范围类控件（Slider、ProgressBar、ScrollBar 等，基类 RangeBase）**
   - `Minimum` / `Maximum`：范围边界
   - `Value`：当前值
   - `SmallChange` / `LargeChange`：微调和大幅度变化值
   - 典型用法：通过绑定将 `Value` 与 ViewModel 数值属性联动

### 4.7 常用控件速查表（用途 + 关键属性）

1. **Button / ToggleButton / CheckBox / RadioButton**
   - 用途：触发命令、状态切换
   - 关键属性：
     - Button：`Content`、`Command`、`CommandParameter`
     - ToggleButton：`IsChecked`、`IsThreeState`
     - CheckBox：继承自 ToggleButton，多用于布尔标记
     - RadioButton：`GroupName` 控制互斥分组

2. **TextBlock / Label**
   - 用途：文本展示
   - TextBlock：轻量、布局灵活，支持内联格式化（`Run`、`Span`）
   - Label：带有 `Target` 属性，可与输入控件联动（辅助无障碍）

3. **ComboBox / ListBox / ListView / DataGrid**
   - 共性：都基于 `ItemsControl` + `Selector`
   - ComboBox：下拉选择（单选），关键属性 `IsEditable`、`SelectedItem`、`SelectedValuePath`
   - ListBox：列表选择（可多选），`SelectionMode`（Single/Multiple/Extended）
   - ListView：基于 ListBox，结合 `View=GridView` 实现列表列头展示
   - DataGrid：表格控件，关键属性：
     - `AutoGenerateColumns`、`Columns`
     - `CanUserAddRows`、`CanUserDeleteRows`、`CanUserSortColumns`
     - `IsReadOnly`

4. **TreeView / Menu / ToolBar**
   - TreeView：树状结构，常与 `HierarchicalDataTemplate` 搭配
   - Menu：菜单栏，配合命令使用
   - ToolBar：工具栏，适合放置图标按钮和常用操作

5. **TabControl / GroupBox / Expander**
   - TabControl：选项卡界面，关键属性 `ItemsSource`、`SelectedItem`、`ItemTemplate`、`ContentTemplate`
   - GroupBox：带标题的内容分组容器
   - Expander：可折叠/展开的容器，关键属性 `IsExpanded`

通过以上“基类 + 常用控件速查”，在查官方文档时可以快速定位到更完整的属性列表。

## 5. 数据绑定（Data Binding）

### 5.1 绑定基础

数据绑定是 WPF 的核心特性之一，它允许 UI 元素与数据源自动同步：

```xaml
<!-- 基本数据绑定 -->
<TextBox Text="{Binding Name}" />
<TextBlock Text="{Binding Age}" />
<Button Content="{Binding ButtonText}" Command="{Binding ClickCommand}" />
```

数据绑定的基本概念：
- **源（Source）**：提供数据的对象
- **目标（Target）**：接收数据的 UI 元素
- **路径（Path）**：源对象中数据的路径
- **模式（Mode）**：绑定的方向
- **更新触发器（UpdateSourceTrigger）**：源更新的触发时机

### 5.2 Binding的关键属性

Binding 对象有以下关键属性：

1. **Source**：绑定的数据源
2. **Path**：数据源中属性的路径
3. **Mode**：绑定模式（OneWay、TwoWay、OneWayToSource、OneTime、Default）
4. **UpdateSourceTrigger**：源更新的触发时机（PropertyChanged、LostFocus、Explicit、Default）
5. **Converter**：值转换器
6. **ConverterParameter**：传递给转换器的参数
7. **ConverterCulture**：转换器使用的文化信息
8. **StringFormat**：字符串格式化
9. **TargetNullValue**：目标为空时的值
10. **FallbackValue**：绑定失败时的值
11. **ValidatesOnDataErrors**：是否启用数据错误验证
12. **ValidatesOnExceptions**：是否启用异常验证
13. **NotifyOnValidationError**：是否在验证错误时触发事件

### 5.3 绑定模式（Mode）

| 绑定模式 | 描述 | 适用场景 |
|---------|------|----------|
| OneWay | 从源到目标的单向绑定 | 显示数据，不需要用户修改 |
| TwoWay | 双向绑定，源和目标相互同步 | 编辑表单，需要双向同步 |
| OneWayToSource | 从目标到源的单向绑定 | 仅需要将 UI 值传递给数据源 |
| OneTime | 只绑定一次，后续变化不影响 | 静态数据，不需要更新 |
| Default | 根据目标属性的默认行为 | 大多数情况下的默认选择 |

### 5.4 值转换器（ValueConverter）

值转换器用于在绑定过程中转换数据类型或格式化数据：

```csharp
// 日期转换器示例
public class DateConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is DateTime date)
        {
            return date.ToString("yyyy-MM-dd");
        }
        return string.Empty;
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is string str && DateTime.TryParse(str, out DateTime date))
        {
            return date;
        }
        return DateTime.Now;
    }
}
```

使用值转换器：

```xaml
<Window.Resources>
    <local:DateConverter x:Key="DateConverter" />
</Window.Resources>

<TextBlock Text="{Binding BirthDate, Converter={StaticResource DateConverter}}" />
<TextBox Text="{Binding BirthDate, Converter={StaticResource DateConverter}, Mode=TwoWay}" />
```

### 5.5 集合绑定与ObservableCollection

对于集合数据，WPF 提供了特殊的绑定支持：

```csharp
// 使用 ObservableCollection 实现自动更新
public class ViewModel
{
    public ObservableCollection<Person> People { get; set; }
    
    public ViewModel()
    {
        People = new ObservableCollection<Person>
        {
            new Person { Name = "张三", Age = 25 },
            new Person { Name = "李四", Age = 30 },
            new Person { Name = "王五", Age = 35 }
        };
        
        // 添加项
        People.Add(new Person { Name = "赵六", Age = 40 });
        
        // 删除项
        People.RemoveAt(0);
    }
}
```

绑定到集合：

```xaml
<ListBox ItemsSource="{Binding People}">
    <ListBox.ItemTemplate>
        <DataTemplate>
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="{Binding Name}" Width="100" />
                <TextBlock Text="{Binding Age}" />
            </StackPanel>
        </DataTemplate>
    </ListBox.ItemTemplate>
</ListBox>
```

### 5.6 绑定源的查找顺序与 DataContext 传递

理解 `DataContext` 及其传递规则，是掌握绑定行为的基础：

1. **DataContext 的继承规则**
   - 子元素默认继承父元素的 `DataContext`
   - 一旦在某个元素上显式设置了 `DataContext`，该元素及其子元素都以新的 `DataContext` 为准
   - 以下元素**不会**继承 DataContext，需要单独设置：
     - `Binding` 在 `Style`、`ControlTemplate` 中时，默认的源是 `TemplatedParent` 而不是视觉树上的 DataContext
     - 独立弹出的 `Window`、对话框，需手动设置 `DataContext`

2. **Binding.Source / ElementName / RelativeSource 的优先级**
   - 当同时指定多个来源时，优先级为：
     1. `Source`
     2. `ElementName`
     3. `RelativeSource`
     4. 继承的 `DataContext`

3. **典型错误场景**
   - 在 `ItemContainerStyle` 中绑定 `DataContext` 的属性，需要使用 `RelativeSource` 或 `TemplatedParent`
   - 在 `ControlTemplate` 内部想绑定到 ViewModel，需要使用 `RelativeSource TemplatedParent` 然后从控件的 `DataContext` 再取属性

### 5.7 ElementName 与 RelativeSource

1. **ElementName 绑定**
   - 用于绑定到 XAML 中同级或祖先元素的属性：

   ```xaml
   <Slider x:Name="sld" Minimum="0" Maximum="100" Value="20" />
   <TextBlock Text="{Binding ElementName=sld, Path=Value}" Margin="10,0,0,0" />
   ```

   典型用途：多个控件之间联动，如滑块与文本、CheckBox 控制 Panel 的 `IsEnabled` 等。

2. **RelativeSource 绑定**
   - 常见模式：
     - `RelativeSource Self`：绑定到自身属性
     - `RelativeSource FindAncestor`：向上查找指定类型的祖先元素
     - `RelativeSource TemplatedParent`：在模板内部绑定到使用模板的控件

   示例：绑定到最近的 `ListBoxItem`：

   ```xaml
   <TextBlock Text="{Binding RelativeSource={RelativeSource AncestorType=ListBoxItem}, Path=IsSelected}" />
   ```

   在 `ControlTemplate` 中绑定到控件自身的 `IsMouseOver`：

   ```xaml
   <Border Background="{Binding RelativeSource={RelativeSource TemplatedParent}, Path=Background}">
       <ContentPresenter />
   </Border>
   ```

### 5.8 MultiBinding 与 PriorityBinding

当单一 Binding 无法满足需求时，可以使用 `MultiBinding` 与 `PriorityBinding`：

1. **MultiBinding**
   - 将多个源值组合成一个目标值，需要实现 `IMultiValueConverter`：

   ```csharp
   public class FullNameConverter : IMultiValueConverter
   {
       public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
       {
           var firstName = values[0] as string;
           var lastName = values[1] as string;
           return $"{lastName}{firstName}";
       }

       public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
       {
           var full = value as string ?? string.Empty;
           if (full.Length >= 2)
               return new object[] { full.Substring(1), full.Substring(0, 1) };
           return new object[] { string.Empty, string.Empty };
       }
   }
   ```

   ```xaml
   <Window.Resources>
       <local:FullNameConverter x:Key="FullNameConverter" />
   </Window.Resources>

   <TextBlock>
       <TextBlock.Text>
           <MultiBinding Converter="{StaticResource FullNameConverter}">
               <Binding Path="FirstName" />
               <Binding Path="LastName" />
           </MultiBinding>
       </TextBlock.Text>
   </TextBlock>
   ```

2. **PriorityBinding**
   - 为目标属性提供一组候选绑定，按顺序使用第一个成功的绑定：

   ```xaml
   <TextBlock>
       <TextBlock.Text>
           <PriorityBinding>
               <!-- 优先使用服务器数据 -->
               <Binding Path="ServerTitle" FallbackValue="{x:Null}" />
               <!-- 其次使用本地缓存 -->
               <Binding Path="LocalTitle" FallbackValue="{x:Null}" />
               <!-- 最后使用硬编码默认值 -->
               <Binding Source="默认标题" />
           </PriorityBinding>
       </TextBlock.Text>
   </TextBlock>
   ```

### 5.9 Binding 常用参数组合清单

1. **文本输入场景**

```xaml
<TextBox Text="{Binding UserName,
                        Mode=TwoWay,
                        UpdateSourceTrigger=PropertyChanged,
                        ValidatesOnDataErrors=True,
                        NotifyOnValidationError=True}" />
```

2. **只读展示场景**

```xaml
<TextBlock Text="{Binding OrderTotal,
                          Mode=OneWay,
                          StringFormat='总金额：{0:C2}'}" />
```

3. **模板内部绑定到 ViewModel 属性**

```xaml
<ControlTemplate TargetType="Button">
    <Border Background="{TemplateBinding Background}">
        <TextBlock Text="{Binding DataContext.ButtonCaption,
                                  RelativeSource={RelativeSource TemplatedParent}}" />
    </Border>
</ControlTemplate>
```

4. **带转换器与参数的绑定**

```xaml
<TextBlock Text="{Binding Progress,
                          Converter={StaticResource ProgressToPercentConverter},
                          ConverterParameter='0'}" />
```

## 6. MVVM设计模式

### 6.1 MVVM的基本概念

MVVM（Model-View-ViewModel）是一种专门为 WPF 设计的设计模式，它将应用程序分为三个主要部分：

1. **Model**：数据模型，包含业务逻辑和数据访问
2. **View**：视图，用户界面，由 XAML 定义
3. **ViewModel**：视图模型，连接 Model 和 View，包含 UI 逻辑

MVVM 的主要优点：
- 关注点分离：UI 和业务逻辑分离
- 可测试性：ViewModel 可以独立于 View 进行测试
- 可维护性：代码结构清晰，易于维护
- 可重用性：ViewModel 可以在不同的 View 中重用

### 6.2 ViewModel的职责

ViewModel 的主要职责包括：

1. **数据转换**：将 Model 中的数据转换为 View 可以显示的形式
2. **状态管理**：管理 View 的状态
3. **命令处理**：处理用户的交互命令
4. **数据验证**：验证用户输入的数据
5. **导航逻辑**：处理页面或视图之间的导航
6. **服务协调**：协调各种服务的调用

### 6.3 INotifyPropertyChanged接口

INotifyPropertyChanged 接口用于通知 View 数据源的属性值发生了变化：

```csharp
public class Person : INotifyPropertyChanged
{
    private string _name;
    private int _age;
    
    public string Name
    {
        get { return _name; }
        set
        {
            if (_name != value)
            {
                _name = value;
                OnPropertyChanged(nameof(Name));
            }
        }
    }
    
    public int Age
    {
        get { return _age; }
        set
        {
            if (_age != value)
            {
                _age = value;
                OnPropertyChanged(nameof(Age));
            }
        }
    }
    
    public event PropertyChangedEventHandler PropertyChanged;
    
    protected virtual void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
```

### 6.4 命令（ICommand）实现

ICommand 接口用于实现命令模式，将用户操作与业务逻辑分离：

```csharp
public class RelayCommand : ICommand
{
    private readonly Action<object> _execute;
    private readonly Func<object, bool> _canExecute;
    
    public event EventHandler CanExecuteChanged;
    
    public RelayCommand(Action<object> execute, Func<object, bool> canExecute = null)
    {
        _execute = execute;
        _canExecute = canExecute;
    }
    
    public bool CanExecute(object parameter)
    {
        return _canExecute == null || _canExecute(parameter);
    }
    
    public void Execute(object parameter)
    {
        _execute(parameter);
    }
    
    public void RaiseCanExecuteChanged()
    {
        CanExecuteChanged?.Invoke(this, EventArgs.Empty);
    }
}
```

使用 RelayCommand：

```csharp
public class ViewModel
{
    public ICommand SaveCommand { get; set; }
    public ICommand DeleteCommand { get; set; }
    
    public ViewModel()
    {
        SaveCommand = new RelayCommand(Save, CanSave);
        DeleteCommand = new RelayCommand(Delete, CanDelete);
    }
    
    private void Save(object parameter)
    {
        // 保存逻辑
    }
    
    private bool CanSave(object parameter)
    {
        // 检查是否可以保存
        return true;
    }
    
    private void Delete(object parameter)
    {
        // 删除逻辑
    }
    
    private bool CanDelete(object parameter)
    {
        // 检查是否可以删除
        return true;
    }
}
```

### 6.5 MVVM示例

```xaml
<!-- View -->
<Window x:Class="MyWpfApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:MyWpfApp"
        Title="MVVM示例" Height="450" Width="800">
    <Window.DataContext>
        <local:MainViewModel />
    </Window.DataContext>
    
    <Grid>
        <StackPanel Margin="20">
            <TextBlock Text="用户管理" FontSize="20" FontWeight="Bold" Margin="0,0,0,20" />
            
            <ListBox ItemsSource="{Binding Users}" SelectedItem="{Binding SelectedUser}" Margin="0,0,0,20">
                <ListBox.ItemTemplate>
                    <DataTemplate>
                        <StackPanel Orientation="Horizontal">
                            <TextBlock Text="{Binding Name}" Width="100" />
                            <TextBlock Text="{Binding Age}" Width="50" />
                            <TextBlock Text="{Binding Email}" />
                        </StackPanel>
                    </DataTemplate>
                </ListBox.ItemTemplate>
            </ListBox>
            
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="100" />
                    <ColumnDefinition Width="*" />
                </Grid.ColumnDefinitions>
                <Grid.RowDefinitions>
                    <RowDefinition Height="30" />
                    <RowDefinition Height="30" />
                    <RowDefinition Height="30" />
                    <RowDefinition Height="40" />
                </Grid.RowDefinitions>
                
                <TextBlock Text="姓名:" Grid.Column="0" Grid.Row="0" VerticalAlignment="Center" />
                <TextBox Text="{Binding SelectedUser.Name, Mode=TwoWay}" Grid.Column="1" Grid.Row="0" />
                
                <TextBlock Text="年龄:" Grid.Column="0" Grid.Row="1" VerticalAlignment="Center" />
                <TextBox Text="{Binding SelectedUser.Age, Mode=TwoWay}" Grid.Column="1" Grid.Row="1" />
                
                <TextBlock Text="邮箱:" Grid.Column="0" Grid.Row="2" VerticalAlignment="Center" />
                <TextBox Text="{Binding SelectedUser.Email, Mode=TwoWay}" Grid.Column="1" Grid.Row="2" />
                
                <StackPanel Orientation="Horizontal" Grid.Column="0" Grid.Row="3" Grid.ColumnSpan="2" HorizontalAlignment="Right" Margin="0,10,0,0">
                    <Button Content="添加" Command="{Binding AddCommand}" Margin="0,0,10,0" />
                    <Button Content="保存" Command="{Binding SaveCommand}" Margin="0,0,10,0" />
                    <Button Content="删除" Command="{Binding DeleteCommand}" />
                </StackPanel>
            </Grid>
        </StackPanel>
    </Grid>
</Window>
```

```csharp
// Model
public class User : INotifyPropertyChanged
{
    private string _name;
    private int _age;
    private string _email;
    
    public string Name
    {
        get { return _name; }
        set { SetProperty(ref _name, value); }
    }
    
    public int Age
    {
        get { return _age; }
        set { SetProperty(ref _age, value); }
    }
    
    public string Email
    {
        get { return _email; }
        set { SetProperty(ref _email, value); }
    }
    
    public event PropertyChangedEventHandler PropertyChanged;
    
    protected void SetProperty<T>(ref T field, T value, [CallerMemberName] string propertyName = null)
    {
        if (!EqualityComparer<T>.Default.Equals(field, value))
        {
            field = value;
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}

// ViewModel
public class MainViewModel
{
    public ObservableCollection<User> Users { get; set; }
    public User SelectedUser { get; set; }
    
    public ICommand AddCommand { get; set; }
    public ICommand SaveCommand { get; set; }
    public ICommand DeleteCommand { get; set; }
    
    public MainViewModel()
    {
        Users = new ObservableCollection<User>
        {
            new User { Name = "张三", Age = 25, Email = "zhangsan@example.com" },
            new User { Name = "李四", Age = 30, Email = "lisi@example.com" },
            new User { Name = "王五", Age = 35, Email = "wangwu@example.com" }
        };
        
        SelectedUser = Users[0];
        
        AddCommand = new RelayCommand(AddUser);
        SaveCommand = new RelayCommand(SaveUser);
        DeleteCommand = new RelayCommand(DeleteUser);
    }
    
    private void AddUser(object parameter)
    {
        var newUser = new User { Name = "新用户", Age = 0, Email = "" };
        Users.Add(newUser);
        SelectedUser = newUser;
    }
    
    private void SaveUser(object parameter)
    {
        // 保存逻辑
    }
    
    private void DeleteUser(object parameter)
    {
        if (SelectedUser != null)
        {
            Users.Remove(SelectedUser);
            if (Users.Count > 0)
            {
                SelectedUser = Users[0];
            }
            else
            {
                SelectedUser = new User();
            }
        }
    }
}
```

### 6.6 MVVM 工程结构推荐

常见的 MVVM 工程结构示例：

```text
MyWpfApp
├─ Models
│  ├─ User.cs
│  └─ Order.cs
├─ ViewModels
│  ├─ MainViewModel.cs
│  └─ OrderDetailViewModel.cs
├─ Views
│  ├─ MainWindow.xaml
│  └─ OrderDetailView.xaml
├─ Services
│  ├─ INavigationService.cs
│  ├─ IDataService.cs
│  └─ MessageService.cs
├─ Commands
│  └─ RelayCommand.cs
└─ App.xaml / App.xaml.cs
```

关键思想：

- **View 只关心界面和交互细节**（XAML + 少量 Code-behind 事件转发到命令）
- **ViewModel 不引用具体的 View 类型**，通过接口（服务）做导航、弹窗等操作
- **Model 只关注业务与数据，不依赖 UI 框架**

### 6.7 MVVM 中的异步命令与长耗时操作

在 MVVM 中处理异步操作时，通常会引入“异步命令”：

```csharp
public class AsyncCommand : ICommand
{
    private readonly Func<Task> _execute;
    private readonly Func<bool> _canExecute;
    private bool _isExecuting;

    public event EventHandler CanExecuteChanged;

    public AsyncCommand(Func<Task> execute, Func<bool> canExecute = null)
    {
        _execute = execute;
        _canExecute = canExecute;
    }

    public bool CanExecute(object parameter)
    {
        return !_isExecuting && (_canExecute?.Invoke() ?? true);
    }

    public async void Execute(object parameter)
    {
        _isExecuting = true;
        RaiseCanExecuteChanged();
        try
        {
            await _execute();
        }
        finally
        {
            _isExecuting = false;
            RaiseCanExecuteChanged();
        }
    }

    private void RaiseCanExecuteChanged()
    {
        CanExecuteChanged?.Invoke(this, EventArgs.Empty);
    }
}
```

在 ViewModel 中使用：

```csharp
public class DashboardViewModel
{
    public ICommand LoadDataCommand { get; }

    private bool _isBusy;
    public bool IsBusy
    {
        get => _isBusy;
        set { _isBusy = value; /* OnPropertyChanged 省略 */ }
    }

    public DashboardViewModel()
    {
        LoadDataCommand = new AsyncCommand(LoadDataAsync, () => !IsBusy);
    }

    private async Task LoadDataAsync()
    {
        IsBusy = true;
        try
        {
            await Task.Delay(1000);
            // 加载数据逻辑
        }
        finally
        {
            IsBusy = false;
        }
    }
}
```

### 6.8 MVVM 中的验证与错误提示

MVVM 中常用两种验证接口：`IDataErrorInfo` 与 `INotifyDataErrorInfo`。

1. **IDataErrorInfo（简单同步验证）**

```csharp
public class UserEditModel : INotifyPropertyChanged, IDataErrorInfo
{
    public string Name { get; set; }
    public int Age { get; set; }

    public string Error => null;

    public string this[string columnName]
    {
        get
        {
            return columnName switch
            {
                nameof(Name) when string.IsNullOrWhiteSpace(Name) => "姓名不能为空",
                nameof(Age) when Age <= 0 || Age > 120 => "年龄范围不合法",
                _ => null
            };
        }
    }
}
```

配合绑定使用：

```xaml
<TextBox Text="{Binding Name, UpdateSourceTrigger=PropertyChanged, ValidatesOnDataErrors=True}" />
<TextBox Text="{Binding Age, UpdateSourceTrigger=PropertyChanged, ValidatesOnDataErrors=True}" />
```

2. **INotifyDataErrorInfo（适合异步/复杂验证）**

用于需要异步验证（例如服务端校验）时，错误集合可按属性名维护。

### 6.9 MVVM 单元测试要点

MVVM 最大的优势之一是 ViewModel 易于测试：

- ViewModel 不依赖具体 UI 控件，只依赖接口和模型
- 命令逻辑可通过直接调用 `Execute` / `CanExecute` 测试
- 通过 Mock（模拟）服务测试导航、消息弹出等行为

示例（伪代码）：

```csharp
[Fact]
public void SaveCommand_Should_Disable_When_Model_Invalid()
{
    var dataService = new FakeDataService();
    var vm = new EditUserViewModel(dataService);

    vm.User.Name = string.Empty;

    Assert.False(vm.SaveCommand.CanExecute(null));
}
```

## 7. 样式与模板

### 7.1 样式（Style）基础

样式用于定义控件的外观，避免重复设置相同的属性：

```xaml
<Window.Resources>
    <!-- 基本样式 -->
    <Style x:Key="ButtonStyle" TargetType="Button">
        <Setter Property="Background" Value="Blue" />
        <Setter Property="Foreground" Value="White" />
        <Setter Property="FontSize" Value="14" />
        <Setter Property="Padding" Value="10,5" />
        <Setter Property="Margin" Value="5" />
    </Style>
    
    <!-- 继承样式 -->
    <Style x:Key="PrimaryButtonStyle" TargetType="Button" BasedOn="{StaticResource ButtonStyle}">
        <Setter Property="Background" Value="Green" />
    </Style>
    
    <!-- 隐式样式 -->
    <Style TargetType="TextBlock">
        <Setter Property="FontSize" Value="14" />
        <Setter Property="Margin" Value="5" />
    </Style>
</Window.Resources>

<!-- 使用样式 -->
<Button Content="普通按钮" Style="{StaticResource ButtonStyle}" />
<Button Content="主要按钮" Style="{StaticResource PrimaryButtonStyle}" />
<TextBlock Text="这是一个文本块" />
```

### 7.2 触发器（Trigger）

触发器用于响应属性变化，动态改变控件的外观：

```xaml
<Style TargetType="Button">
    <Setter Property="Background" Value="Blue" />
    <Setter Property="Foreground" Value="White" />
    <Setter Property="Padding" Value="10,5" />
    <Setter Property="Margin" Value="5" />
    
    <Style.Triggers>
        <!-- 属性触发器 -->
        <Trigger Property="IsMouseOver" Value="True">
            <Setter Property="Background" Value="LightBlue" />
            <Setter Property="Cursor" Value="Hand" />
        </Trigger>
        
        <!-- 事件触发器 -->
        <EventTrigger RoutedEvent="MouseDown">
            <BeginStoryboard>
                <Storyboard>
                    <DoubleAnimation Storyboard.TargetProperty="Width" From="100" To="120" Duration="0:0:0.2" />
                </Storyboard>
            </BeginStoryboard>
        </EventTrigger>
        
        <!-- 数据触发器 -->
        <DataTrigger Binding="{Binding IsEnabled}" Value="False">
            <Setter Property="Background" Value="Gray" />
            <Setter Property="Foreground" Value="LightGray" />
        </DataTrigger>
    </Style.Triggers>
</Style>
```

### 7.3 控件模板（ControlTemplate）

控件模板用于完全自定义控件的外观：

```xaml
<ControlTemplate x:Key="CustomButtonTemplate" TargetType="Button">
    <Border x:Name="Border" 
            Background="{TemplateBinding Background}"
            BorderBrush="{TemplateBinding BorderBrush}"
            BorderThickness="{TemplateBinding BorderThickness}"
            CornerRadius="5">
        <StackPanel Orientation="Horizontal" HorizontalAlignment="Center" VerticalAlignment="Center">
            <ContentPresenter x:Name="Content" Margin="{TemplateBinding Padding}" />
        </StackPanel>
    </Border>
    <ControlTemplate.Triggers>
        <Trigger Property="IsMouseOver" Value="True">
            <Setter TargetName="Border" Property="Background" Value="LightBlue" />
        </Trigger>
        <Trigger Property="IsPressed" Value="True">
            <Setter TargetName="Border" Property="Background" Value="DarkBlue" />
            <Setter TargetName="Content" Property="Margin" Value="12,7,8,3" />
        </Trigger>
        <Trigger Property="IsEnabled" Value="False">
            <Setter TargetName="Border" Property="Background" Value="Gray" />
            <Setter TargetName="Border" Property="BorderBrush" Value="LightGray" />
        </Trigger>
    </ControlTemplate.Triggers>
</ControlTemplate>

<Button Content="自定义按钮" Template="{StaticResource CustomButtonTemplate}" Background="Blue" Foreground="White" Padding="10,5" />
```

### 7.4 数据模板（DataTemplate）

数据模板用于定义数据对象的可视化表示：

```xaml
<DataTemplate x:Key="PersonTemplate" DataType="{x:Type local:Person}">
    <Border BorderBrush="Gray" BorderThickness="1" Padding="10" Margin="5" CornerRadius="5">
        <StackPanel>
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="姓名: " FontWeight="Bold" />
                <TextBlock Text="{Binding Name}" />
            </StackPanel>
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="年龄: " FontWeight="Bold" />
                <TextBlock Text="{Binding Age}" />
            </StackPanel>
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="邮箱: " FontWeight="Bold" />
                <TextBlock Text="{Binding Email}" />
            </StackPanel>
        </StackPanel>
    </Border>
</DataTemplate>

<ContentControl Content="{Binding SelectedPerson}" ContentTemplate="{StaticResource PersonTemplate}" />

<ListBox ItemsSource="{Binding People}" ItemTemplate="{StaticResource PersonTemplate}" />
```

### 7.5 资源（Resource）与资源字典

资源字典用于集中管理和共享资源：

```xaml
<!-- Styles.xaml -->
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <SolidColorBrush x:Key="PrimaryColor" Color="Blue" />
    <SolidColorBrush x:Key="SecondaryColor" Color="Green" />
    
    <Style x:Key="ButtonStyle" TargetType="Button">
        <Setter Property="Background" Value="{StaticResource PrimaryColor}" />
        <Setter Property="Foreground" Value="White" />
        <Setter Property="Padding" Value="10,5" />
    </Style>
</ResourceDictionary>

<!-- 在 App.xaml 中引用 -->
<Application.Resources>
    <ResourceDictionary>
        <ResourceDictionary.MergedDictionaries>
            <ResourceDictionary Source="Styles.xaml" />
        </ResourceDictionary.MergedDictionaries>
    </ResourceDictionary>
</Application.Resources>

<!-- 在窗口中引用 -->
<Window.Resources>
    <ResourceDictionary>
        <ResourceDictionary.MergedDictionaries>
            <ResourceDictionary Source="Styles.xaml" />
        </ResourceDictionary.MergedDictionaries>
        
        <!-- 窗口特定资源 -->
        <Style x:Key="WindowButtonStyle" TargetType="Button" BasedOn="{StaticResource ButtonStyle}">
            <Setter Property="Margin" Value="5" />
        </Style>
    </ResourceDictionary>
</Window.Resources>
```

### 7.6 TemplateBinding 与 RelativeSource TemplatedParent

在 `ControlTemplate` 内部访问控件本身的属性时，常见两种写法：`TemplateBinding` 与 `RelativeSource TemplatedParent`。

1. **TemplateBinding**
   - 语法简洁，性能较好
   - 只能用于简单的“一对一属性映射”，不支持转换器、字符串格式等

```xaml
<ControlTemplate TargetType="Button">
    <Border Background="{TemplateBinding Background}"
            BorderBrush="{TemplateBinding BorderBrush}"
            BorderThickness="{TemplateBinding BorderThickness}">
        <ContentPresenter Margin="{TemplateBinding Padding}"
                          HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}"
                          VerticalAlignment="{TemplateBinding VerticalContentAlignment}" />
    </Border>
</ControlTemplate>
```

2. **RelativeSource TemplatedParent**
   - 完整的 Binding 语法，支持 Converter、StringFormat 等

```xaml
<ControlTemplate TargetType="Button">
    <Border>
        <Border.Background>
            <SolidColorBrush Color="{Binding RelativeSource={RelativeSource TemplatedParent},
                                             Path=Tag,
                                             Converter={StaticResource TagToColorConverter}}" />
        </Border.Background>
        <ContentPresenter />
    </Border>
</ControlTemplate>
```

一般原则：

- 简单属性映射用 `TemplateBinding`
- 需要转换器、复杂路径、绑定到 DataContext 时用 `RelativeSource TemplatedParent`

### 7.7 ItemsControl 模板体系：ItemTemplate、ItemsPanel、ItemContainerStyle

`ItemsControl` 及其子类有一套完整的模板体系：

1. **ItemTemplate（每一行长什么样）**

```xaml
<ListBox ItemsSource="{Binding People}">
    <ListBox.ItemTemplate>
        <DataTemplate>
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="{Binding Name}" Width="100" />
                <TextBlock Text="{Binding Age}" />
            </StackPanel>
        </DataTemplate>
    </ListBox.ItemTemplate>
</ListBox>
```

2. **ItemsPanel（所有行如何排列）**

```xaml
<ListBox ItemsSource="{Binding People}">
    <ListBox.ItemsPanel>
        <ItemsPanelTemplate>
            <WrapPanel />
        </ItemsPanelTemplate>
    </ListBox.ItemsPanel>
</ListBox>
```

3. **ItemContainerStyle（容器行为与样式）**

```xaml
<ListBox ItemsSource="{Binding People}" SelectionMode="Multiple">
    <ListBox.ItemContainerStyle>
        <Style TargetType="ListBoxItem">
            <Setter Property="Margin" Value="2" />
            <Setter Property="HorizontalContentAlignment" Value="Stretch" />
            <Style.Triggers>
                <Trigger Property="IsSelected" Value="True">
                    <Setter Property="Background" Value="#333333" />
                    <Setter Property="Foreground" Value="White" />
                </Trigger>
            </Style.Triggers>
        </Style>
    </ListBox.ItemContainerStyle>
</ListBox>
```

4. **HierarchicalDataTemplate（层级数据模板，常用于 TreeView）**

```xaml
<TreeView ItemsSource="{Binding Departments}">
    <TreeView.ItemTemplate>
        <HierarchicalDataTemplate ItemsSource="{Binding Employees}">
            <TextBlock Text="{Binding Name}" />
        </HierarchicalDataTemplate>
    </TreeView.ItemTemplate>
</TreeView>
```

### 7.8 VisualStateManager 与控件状态

对于复杂控件状态（普通、鼠标悬停、按下、禁用等），可以使用 `VisualStateManager` 管理视觉状态：

```xaml
<ControlTemplate x:Key="StatefulButtonTemplate" TargetType="Button">
    <Grid x:Name="Root">
        <VisualStateManager.VisualStateGroups>
            <VisualStateGroup x:Name="CommonStates">
                <VisualState x:Name="Normal" />
                <VisualState x:Name="MouseOver">
                    <Storyboard>
                        <ColorAnimation Storyboard.TargetName="BorderBrush"
                                        Storyboard.TargetProperty="Color"
                                        To="Orange" Duration="0:0:0.2" />
                    </Storyboard>
                </VisualState>
                <VisualState x:Name="Pressed">
                    <Storyboard>
                        <DoubleAnimation Storyboard.TargetName="Root"
                                         Storyboard.TargetProperty="Opacity"
                                         To="0.7" Duration="0:0:0.1" />
                    </Storyboard>
                </VisualState>
                <VisualState x:Name="Disabled">
                    <Storyboard>
                        <DoubleAnimation Storyboard.TargetName="Root"
                                         Storyboard.TargetProperty="Opacity"
                                         To="0.4" Duration="0:0:0.2" />
                    </Storyboard>
                </VisualState>
            </VisualStateGroup>
        </VisualStateManager.VisualStateGroups>

        <Border CornerRadius="4" Padding="{TemplateBinding Padding}">
            <Border.BorderBrush>
                <SolidColorBrush x:Name="BorderBrush" Color="Gray" />
            </Border.BorderBrush>
            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center" />
        </Border>
    </Grid>
</ControlTemplate>

<Button Content="状态按钮"
        Template="{StaticResource StatefulButtonTemplate}" />
```

`VisualStateManager` 适合状态较多、需要平滑动画过渡的控件，对复杂 UI 的可维护性帮助较大。

## 8. 动画与图形

### 8.1 动画基础

WPF 提供了强大的动画系统，支持各种类型的动画：

1. **属性动画**：改变控件的属性值
2. **路径动画**：沿着路径移动元素
3. **关键帧动画**：定义多个关键帧，实现更复杂的动画
4. **故事板**：组合多个动画，实现复杂的动画序列

### 8.2 DoubleAnimation与ColorAnimation

DoubleAnimation 用于动画数值类型的属性：

```xaml
<Button Content="动画按钮" Width="100" Height="40">
    <Button.Triggers>
        <EventTrigger RoutedEvent="MouseEnter">
            <BeginStoryboard>
                <Storyboard>
                    <DoubleAnimation Storyboard.TargetProperty="Width" From="100" To="150" Duration="0:0:0.5" />
                    <DoubleAnimation Storyboard.TargetProperty="Height" From="40" To="60" Duration="0:0:0.5" />
                </Storyboard>
            </BeginStoryboard>
        </EventTrigger>
        <EventTrigger RoutedEvent="MouseLeave">
            <BeginStoryboard>
                <Storyboard>
                    <DoubleAnimation Storyboard.TargetProperty="Width" From="150" To="100" Duration="0:0:0.5" />
                    <DoubleAnimation Storyboard.TargetProperty="Height" From="60" To="40" Duration="0:0:0.5" />
                </Storyboard>
            </BeginStoryboard>
        </EventTrigger>
    </Button.Triggers>
</Button>
```

ColorAnimation 用于动画颜色类型的属性：

```xaml
<Rectangle Width="200" Height="100">
    <Rectangle.Fill>
        <SolidColorBrush x:Name="RectBrush" Color="Blue" />
    </Rectangle.Fill>
    <Rectangle.Triggers>
        <EventTrigger RoutedEvent="Loaded">
            <BeginStoryboard>
                <Storyboard RepeatBehavior="Forever" AutoReverse="True">
                    <ColorAnimation Storyboard.TargetName="RectBrush" 
                                   Storyboard.TargetProperty="Color" 
                                   From="Blue" To="Red" 
                                   Duration="0:0:2" />
                </Storyboard>
            </BeginStoryboard>
        </EventTrigger>
    </Rectangle.Triggers>
</Rectangle>
```

### 8.3 Storyboard详解

Storyboard 用于组合和控制多个动画：

```xaml
<Storyboard x:Key="FadeInOutAnimation">
    <DoubleAnimation Storyboard.TargetProperty="Opacity" 
                     From="0" To="1" 
                     Duration="0:0:1" 
                     BeginTime="0:0:0" />
    <DoubleAnimation Storyboard.TargetProperty="Opacity" 
                     From="1" To="0" 
                     Duration="0:0:1" 
                     BeginTime="0:0:2" />
</Storyboard>

<TextBlock Text="淡入淡出动画" Opacity="0">
    <TextBlock.Triggers>
        <EventTrigger RoutedEvent="Loaded">
            <BeginStoryboard Storyboard="{StaticResource FadeInOutAnimation}" RepeatBehavior="Forever" />
        </EventTrigger>
    </TextBlock.Triggers>
</TextBlock>
```

### 8.4 绘图与形状

WPF 提供了丰富的绘图和形状功能：

```xaml
<Canvas Width="400" Height="300" Background="LightGray">
    <!-- 基本形状 -->
    <Rectangle Width="100" Height="100" Fill="Red" Canvas.Left="50" Canvas.Top="50" />
    <Ellipse Width="100" Height="100" Fill="Blue" Canvas.Left="200" Canvas.Top="50" />
    <Line X1="50" Y1="200" X2="150" Y2="250" Stroke="Green" StrokeThickness="2" />
    <Path Data="M 50,200 L 150,200 L 100,150 Z" Fill="Yellow" />
    
    <!-- 复杂路径 -->
    <Path Data="M 200,200 C 250,150 350,150 350,200 S 250,250 200,200" 
          Stroke="Purple" StrokeThickness="2" Fill="Transparent" />
    
    <!-- 文本 -->
    <TextBlock Text="WPF 绘图示例" FontSize="16" FontWeight="Bold" Canvas.Left="100" Canvas.Top="250" />
</Canvas>
```

## 9. 路由事件与命令系统

### 9.1 路由事件的机制

WPF 的路由事件系统允许事件从子元素冒泡到父元素，或从父元素隧道到子元素：

1. **冒泡事件（Bubbling）**：从事件源向上传播到视觉树的根
2. **隧道事件（Tunneling）**：从视觉树的根向下传播到事件源
3. **直接事件（Direct）**：只在事件源上触发，不传播

路由事件的处理：

```csharp
// 处理冒泡事件
private void Button_Click(object sender, RoutedEventArgs e)
{
    // 处理点击事件
    e.Handled = true; // 阻止事件继续传播
}

// 处理隧道事件
private void Grid_PreviewMouseDown(object sender, MouseButtonEventArgs e)
{
    // 处理鼠标按下事件
}
```

### 9.2 冒泡与隧道事件

```xaml
<Grid PreviewMouseDown="Grid_PreviewMouseDown" MouseDown="Grid_MouseDown" Background="LightGray" Padding="20">
    <StackPanel PreviewMouseDown="StackPanel_PreviewMouseDown" MouseDown="StackPanel_MouseDown" Background="LightBlue" Padding="10">
        <Button Content="点击我" PreviewMouseDown="Button_PreviewMouseDown" Click="Button_Click" />
    </StackPanel>
</Grid>
```

事件触发顺序：
1. Grid.PreviewMouseDown（隧道）
2. StackPanel.PreviewMouseDown（隧道）
3. Button.PreviewMouseDown（隧道）
4. Button.Click（直接）
5. Button.MouseDown（冒泡）
6. StackPanel.MouseDown（冒泡）
7. Grid.MouseDown（冒泡）

### 9.3 命令（Command）机制

WPF 的命令系统提供了一种将用户操作与业务逻辑分离的方式：

1. **命令源（Command Source）**：触发命令的元素，如 Button、MenuItem
2. **命令目标（Command Target）**：命令的执行目标，如 TextBox
3. **命令绑定（Command Binding）**：将命令与处理方法关联
4. **命令（Command）**：表示要执行的操作，如 ApplicationCommands.Copy

```xaml
<Window.CommandBindings>
    <CommandBinding Command="ApplicationCommands.Open" 
                    Executed="OpenCommand_Executed" 
                    CanExecute="OpenCommand_CanExecute" />
    <CommandBinding Command="ApplicationCommands.Save" 
                    Executed="SaveCommand_Executed" 
                    CanExecute="SaveCommand_CanExecute" />
</Window.CommandBindings>

<StackPanel>
    <MenuItem Header="文件">
        <MenuItem Header="打开" Command="ApplicationCommands.Open" />
        <MenuItem Header="保存" Command="ApplicationCommands.Save" />
    </MenuItem>
    <Button Content="打开" Command="ApplicationCommands.Open" />
    <Button Content="保存" Command="ApplicationCommands.Save" />
</StackPanel>
```

```csharp
private void OpenCommand_Executed(object sender, ExecutedRoutedEventArgs e)
{
    // 执行打开操作
}

private void OpenCommand_CanExecute(object sender, CanExecuteRoutedEventArgs e)
{
    e.CanExecute = true; // 检查是否可以执行
}

private void SaveCommand_Executed(object sender, ExecutedRoutedEventArgs e)
{
    // 执行保存操作
}

private void SaveCommand_CanExecute(object sender, CanExecuteRoutedEventArgs e)
{
    e.CanExecute = true; // 检查是否可以执行
}
```

### 9.4 自定义命令

除了使用内置命令，还可以创建自定义命令：

```csharp
public static class CustomCommands
{
    public static readonly RoutedUICommand Exit = new RoutedUICommand(
        "退出", "Exit", typeof(CustomCommands),
        new InputGestureCollection { new KeyGesture(Key.F4, ModifierKeys.Alt) });
    
    public static readonly RoutedUICommand About = new RoutedUICommand(
        "关于", "About", typeof(CustomCommands));
}
```

```xaml
<Window.CommandBindings>
    <CommandBinding Command="local:CustomCommands.Exit" 
                    Executed="ExitCommand_Executed" 
                    CanExecute="ExitCommand_CanExecute" />
    <CommandBinding Command="local:CustomCommands.About" 
                    Executed="AboutCommand_Executed" 
                    CanExecute="AboutCommand_CanExecute" />
</Window.CommandBindings>

<MenuItem Header="帮助">
    <MenuItem Header="关于" Command="local:CustomCommands.About" />
    <Separator />
    <MenuItem Header="退出" Command="local:CustomCommands.Exit" />
</MenuItem>
```

## 10. WPF性能优化与最佳实践

### 10.1 资源管理优化

1. **合理使用资源字典**：将资源集中管理，避免重复定义
2. **使用静态资源**：对于不会变化的资源，使用 StaticResource
3. **延迟加载资源**：对于大型资源，使用延迟加载
4. **释放未使用的资源**：及时释放不再使用的资源
5. **避免内存泄漏**：正确处理事件订阅和资源引用

### 10.2 虚拟化与延迟加载

1. **列表虚拟化**：对于大量数据的列表，使用虚拟化
   ```xaml
   <ListBox ItemsSource="{Binding Items}"
            VirtualizingStackPanel.IsVirtualizing="True"
            VirtualizingStackPanel.VirtualizationMode="Recycling" />
   ```

2. **数据虚拟化**：对于非常大的数据集，使用数据虚拟化
3. **延迟加载**：对于复杂的 UI 元素，使用延迟加载
   ```xaml
   <ContentControl Content="{Binding ComplexContent}" IsAsync="True" />
   ```

### 10.3 绑定性能优化

1. **使用合适的绑定模式**：根据需要选择合适的绑定模式
2. **优化绑定路径**：避免深层嵌套的绑定路径
3. **使用 OneWay 绑定**：对于不需要双向绑定的场景，使用 OneWay 绑定
4. **使用 ObservableCollection**：对于动态集合，使用 ObservableCollection
5. **避免不必要的绑定更新**：合理设置 UpdateSourceTrigger

### 10.4 UI线程与异步操作

1. **使用异步操作**：对于耗时操作，使用异步处理
   ```csharp
   private async void LoadDataButton_Click(object sender, RoutedEventArgs e)
   {
       IsBusy = true;
       try
       {
           await Task.Run(() => LoadData());
       }
       finally
       {
           IsBusy = false;
       }
   }
   ```

2. **使用 Dispatcher**：在非 UI 线程中更新 UI 时，使用 Dispatcher
   ```csharp
   private void BackgroundOperation()
   {
       // 执行后台操作
       
       // 更新 UI
       Application.Current.Dispatcher.Invoke(() =>
       {
           StatusText = "操作完成";
       });
   }
   ```

3. **避免阻塞 UI 线程**：不要在 UI 线程中执行耗时操作
4. **使用进度报告**：对于长时间运行的操作，使用进度报告

### 10.5 性能监控与调试

1. **使用性能分析工具**：
   - Visual Studio 性能分析器
   - WPF 性能工具（PerfView）
   - Snoop（WPF UI 调试工具）

2. **监控视觉树复杂度**：避免过度复杂的视觉树
3. **监控绑定更新**：避免不必要的绑定更新
4. **使用日志**：记录性能关键路径的执行时间
5. **定期测试**：定期进行性能测试，发现问题及时优化

## 11. 总结

WPF 是一个功能强大、灵活多变的用户界面框架，它提供了丰富的功能和工具，使得开发者可以创建高质量、现代化的 Windows 应用程序。通过本文的学习，您应该已经掌握了 WPF 的核心概念和基本技能，包括：

1. **WPF 概述**：了解了 WPF 的基本概念、体系结构和与 WinForms 的区别
2. **XAML 基础**：掌握了 XAML 的语法和基本用法
3. **布局系统**：学会了使用各种布局面板创建复杂的 UI 布局
4. **控件详解**：熟悉了常用控件的使用方法和特性
5. **数据绑定**：掌握了 WPF 的数据绑定机制
6. **MVVM 模式**：理解了 MVVM 设计模式的基本概念和实践方法
7. **样式与模板**：学会了使用样式和模板自定义控件的外观
8. **动画与图形**：掌握了 WPF 的动画和绘图功能
9. **路由事件与命令系统**：理解了 WPF 的事件和命令系统
10. **性能优化**：了解了 WPF 应用程序的性能优化方法

WPF 的学习曲线可能相对陡峭，但一旦掌握，您将能够创建出美观、高效、可维护的 Windows 桌面应用程序。随着 .NET 的不断发展，WPF 也在不断演进，为开发者提供更多的功能和更好的性能。

希望本文能够帮助您快速入门 WPF 开发，并在实践中不断提升自己的技能。祝您开发愉快！

## 参考资料

- [Microsoft WPF 文档](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/)
- [WPF 教程](https://wpf-tutorial.com/)
- [MVVM 模式](https://docs.microsoft.com/en-us/archive/msdn-magazine/2009/february/patterns-wpf-apps-with-the-model-view-viewmodel-design-pattern)
- [WPF 性能优化](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/optimizing-wpf-application-performance)
- [WPF 数据绑定](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/data/)
- [WPF 样式和模板](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/controls/styles-and-templates-overview)
- [WPF 动画](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/graphics-multimedia/animation-overview)
- [WPF 命令](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/commanding-overview)

---

## 12. 依赖属性（DependencyProperty）深入

### 12.1 为什么需要依赖属性

普通 .NET 属性无法满足 WPF 对以下特性的需求：

- **样式与主题**：属性值可由 Style/Theme 统一设定并覆盖默认值
- **数据绑定**：属性需要支持 Binding，以便由外部数据源驱动
- **动画系统**：属性值可被 Storyboard 动态驱动
- **默认值与值继承**：控件树中，子元素可从父元素继承某些属性值（如 `FontFamily`、`Foreground` 等）
- **附加属性（Attached Property）**：允许“看起来像是别人的属性”挂在当前对象上（如 `Grid.Row`）

依赖属性通过 `DependencyProperty` 元数据系统实现上述功能，是 WPF 框架的核心之一。

### 12.2 声明依赖属性的标准写法

以一个自定义控件 `WatermarkTextBox` 为例：

```csharp
public class WatermarkTextBox : TextBox
{
    public static readonly DependencyProperty WatermarkProperty =
        DependencyProperty.Register(
            nameof(Watermark),                 // 属性名
            typeof(string),                    // 类型
            typeof(WatermarkTextBox),          // 所属类型
            new FrameworkPropertyMetadata(     // 元数据（默认值、回调等）
                default(string),
                FrameworkPropertyMetadataOptions.AffectsRender,
                OnWatermarkChanged));

    public string Watermark
    {
        get => (string)GetValue(WatermarkProperty);
        set => SetValue(WatermarkProperty, value);
    }

    private static void OnWatermarkChanged(
        DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        var control = (WatermarkTextBox)d;
        control.InvalidateVisual();
    }
}
```

关键点：

- 静态只读字段名惯例：`<属性名>Property`
- 使用 `GetValue/SetValue` 存取值
- 元数据中可以指定：默认值、是否影响布局 / 渲染、回调方法等

### 12.3 FrameworkPropertyMetadataOptions 常用标志

`FrameworkPropertyMetadataOptions` 通过位标志描述属性变化对控件的影响：

- `AffectsMeasure`：属性变化会影响测量阶段（可能改变控件尺寸）
- `AffectsArrange`：属性变化会影响排列阶段
- `AffectsRender`：属性变化会影响渲染（外观刷新）
- `BindsTwoWayByDefault`：该属性默认使用 TwoWay 绑定模式
- `Inherits`：属性值沿视觉树向下继承（例如 `FontFamily`）
- `OverridesInheritanceBehavior`：覆盖继承行为
- `SubPropertiesDoNotAffectRender`：子属性变化不影响渲染

示例：

```csharp
public static readonly DependencyProperty IsHighlightedProperty =
    DependencyProperty.Register(
        nameof(IsHighlighted),
        typeof(bool),
        typeof(MyControl),
        new FrameworkPropertyMetadata(
            false,
            FrameworkPropertyMetadataOptions.AffectsRender,
            OnIsHighlightedChanged));
```

### 12.4 附加属性（Attached Property）实现

附加属性的声明与普通依赖属性类似，但使用 `RegisterAttached` 并提供静态 `Get/Set` 方法：

```csharp
public static class GridHelpers
{
    public static readonly DependencyProperty IsBusyOverlayProperty =
        DependencyProperty.RegisterAttached(
            "IsBusyOverlay",
            typeof(bool),
            typeof(GridHelpers),
            new FrameworkPropertyMetadata(false, FrameworkPropertyMetadataOptions.Inherits));

    public static void SetIsBusyOverlay(DependencyObject element, bool value)
        => element.SetValue(IsBusyOverlayProperty, value);

    public static bool GetIsBusyOverlay(DependencyObject element)
        => (bool)element.GetValue(IsBusyOverlayProperty);
}
```

使用方式：

```xaml
<Grid local:GridHelpers.IsBusyOverlay="True">
    <!-- 子元素可以通过继承感知这个状态 -->
</Grid>
```

附加属性的典型应用：

- 布局属性（`Grid.Row`、`DockPanel.Dock`）
- 行为挂载（比如 `Interaction.Behaviors`）
- 主题/状态标记（如统一标记某区域为 “Busy”）

### 12.5 依赖属性的值优先级（Value Precedence）

同一个依赖属性可能有多个“来源”：本地值、样式、动画、默认值等，WPF 按以下顺序决定最终值（简化版）：

1. **激活动画 / 可视状态** 设置的值
2. 本地值（XAML/代码中直接设置的属性值）
3. `Style` 中 `Setter` 设置的值
4. `Template` 中基于 `TemplateBinding` 的值
5. 主题样式（系统主题）中的值
6. 继承值（Inherits）
7. 默认值（元数据中的 DefaultValue）

这解释了为什么：

- 如果属性被动画控制，本地赋值看起来“无效”
- 局部样式会覆盖全局样式

### 12.6 自定义只读依赖属性

有时需要公开一个只读的依赖属性（只允许控件自己设置）：

```csharp
public class BusyIndicator : Control
{
    private static readonly DependencyPropertyKey IsBusyPropertyKey =
        DependencyProperty.RegisterReadOnly(
            nameof(IsBusy),
            typeof(bool),
            typeof(BusyIndicator),
            new FrameworkPropertyMetadata(false));

    public static readonly DependencyProperty IsBusyProperty =
        IsBusyPropertyKey.DependencyProperty;

    public bool IsBusy
    {
        get => (bool)GetValue(IsBusyProperty);
        protected set => SetValue(IsBusyPropertyKey, value);
    }

    public async Task RunAsync(Func<Task> work)
    {
        IsBusy = true;
        try
        {
            await work();
        }
        finally
        {
            IsBusy = false;
        }
    }
}
```

---

## 13. 路由事件与命令高级用法

### 13.1 路由事件注册与自定义事件

自定义控件中可以声明自己的路由事件：

```csharp
public class NumericTextBox : TextBox
{
    public static readonly RoutedEvent ValueChangedEvent =
        EventManager.RegisterRoutedEvent(
            nameof(ValueChanged),
            RoutingStrategy.Bubble,
            typeof(RoutedPropertyChangedEventHandler<double?>),
            typeof(NumericTextBox));

    public event RoutedPropertyChangedEventHandler<double?> ValueChanged
    {
        add => AddHandler(ValueChangedEvent, value);
        remove => RemoveHandler(ValueChangedEvent, value);
    }

    private double? _currentValue;

    protected override void OnTextChanged(TextChangedEventArgs e)
    {
        base.OnTextChanged(e);

        if (double.TryParse(Text, out var newValue))
        {
            var old = _currentValue;
            _currentValue = newValue;
            var args = new RoutedPropertyChangedEventArgs<double?>(old, newValue, ValueChangedEvent);
            RaiseEvent(args);
        }
    }
}
```

使用方式：

```xaml
<local:NumericTextBox ValueChanged="NumericTextBox_ValueChanged" />
```

### 13.2 类级事件处理器与弱事件

1. **类级事件处理器**

可以为某个类型注册“类级别”的路由事件处理器，集中处理某个控件的事件：

```csharp
public class GlobalInputManager
{
    public static void Register()
    {
        EventManager.RegisterClassHandler(
            typeof(TextBox),
            UIElement.GotKeyboardFocusEvent,
            new RoutedEventHandler(OnTextBoxGotFocus));
    }

    private static void OnTextBoxGotFocus(object sender, RoutedEventArgs e)
    {
        // 统一处理所有 TextBox 获得焦点
    }
}
```

通常在 `App.xaml.cs` 启动时调用 `GlobalInputManager.Register()`。

2. **弱事件（WeakEventManager）防止内存泄漏**

对于长生命周期对象订阅短生命周期对象的事件时，推荐使用弱事件模式：

```csharp
public class LogViewModel
{
    public LogViewModel(Logger logger)
    {
        WeakEventManager<Logger, LogEventArgs>.AddHandler(logger, nameof(Logger.Logged), OnLogged);
    }

    private void OnLogged(object sender, LogEventArgs e)
    {
        // 处理日志
    }
}
```

### 13.3 CommandBinding 与 MVVM 的取舍

在 MVVM 中，一般推荐用 `ICommand` + 绑定代替 Code-behind 中的 `CommandBinding`，但以下场景使用 `CommandBinding` 更自然：

- 顶层窗口需要处理“全局快捷键命令”（如 Ctrl+S、Ctrl+O）
- 命令逻辑强依赖于 UI 结构（例如文档视图/编辑器）

示例：

```xaml
<Window.CommandBindings>
    <CommandBinding Command="ApplicationCommands.Close"
                    Executed="Close_Executed"
                    CanExecute="Close_CanExecute" />
</Window.CommandBindings>

<Window.InputBindings>
    <KeyBinding Command="ApplicationCommands.Close"
                Key="F4" Modifiers="Alt" />
</Window.InputBindings>
```

### 13.4 输入绑定（InputBinding）与手势

`InputBinding` 可以将键盘/鼠标手势映射到命令：

```xaml
<Window.InputBindings>
    <KeyBinding Command="{Binding SaveCommand}"
                Key="S" Modifiers="Ctrl" />
    <MouseBinding Command="{Binding OpenContextMenuCommand}"
                  MouseAction="RightClick" />
</Window.InputBindings>
```

注意：

- 绑定到 ViewModel 命令时，Window 需要正确的 `DataContext`
- 命令执行前会调用 `CanExecute` 判断是否可用

---

## 14. 自定义控件、用户控件与行为

### 14.1 UserControl vs Custom Control

1. **UserControl（用户控件）**

- 本质是把一段 XAML UI 组合打包成一个可重用单元
- 优点：
  - 开发简单、所见即所得
  - 适合 UI 结构固定、主要在本项目中复用的组件
- 缺点：
  - 难以重做样式（外部难以完全替换其外观）
  - 模板化能力有限

2. **Custom Control（派生自 Control 的自定义控件）**

- 外观完全由 `ControlTemplate` 决定
- 优点：
  - 支持主题、皮肤、模板替换
  - 适合做“库级组件”（类似标准 WPF 控件）
- 缺点：
  - 初期开发门槛更高，需要写 `Generic.xaml` 模板

### 14.2 自定义控件基本结构

1. 新建类并继承自 `Control`（或其他基类）

```csharp
public class Badge : Control
{
    static Badge()
    {
        DefaultStyleKeyProperty.OverrideMetadata(
            typeof(Badge),
            new FrameworkPropertyMetadata(typeof(Badge)));
    }

    public static readonly DependencyProperty ContentProperty =
        DependencyProperty.Register(
            nameof(Content),
            typeof(object),
            typeof(Badge),
            new PropertyMetadata(null));

    public object Content
    {
        get => GetValue(ContentProperty);
        set => SetValue(ContentProperty, value);
    }
}
```

2. 在 `Themes/Generic.xaml` 中定义默认模板：

```xaml
<ResourceDictionary
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="clr-namespace:MyControls">

    <Style TargetType="{x:Type local:Badge}">
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="{x:Type local:Badge}">
                    <Border Background="Red"
                            CornerRadius="10"
                            Padding="4,1">
                        <ContentPresenter HorizontalAlignment="Center"
                                          VerticalAlignment="Center"
                                          Content="{TemplateBinding Content}"
                                          Foreground="White"
                                          FontSize="10" />
                    </Border>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>

</ResourceDictionary>
```

3. 使用：

```xaml
<local:Badge Content="99+" />
```

### 14.3 自定义附加行为：交互逻辑的无侵入扩展

不想派生新控件，只想在现有控件上“挂一个行为”，可以使用附加属性 + 事件处理：

```csharp
public static class TextBoxBehaviors
{
    public static readonly DependencyProperty SelectAllOnFocusProperty =
        DependencyProperty.RegisterAttached(
            "SelectAllOnFocus",
            typeof(bool),
            typeof(TextBoxBehaviors),
            new PropertyMetadata(false, OnSelectAllOnFocusChanged));

    public static void SetSelectAllOnFocus(DependencyObject element, bool value)
        => element.SetValue(SelectAllOnFocusProperty, value);

    public static bool GetSelectAllOnFocus(DependencyObject element)
        => (bool)element.GetValue(SelectAllOnFocusProperty);

    private static void OnSelectAllOnFocusChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        if (d is TextBox textBox)
        {
            if ((bool)e.NewValue)
            {
                textBox.GotKeyboardFocus += TextBox_GotKeyboardFocus;
                textBox.PreviewMouseLeftButtonDown += TextBox_PreviewMouseLeftButtonDown;
            }
            else
            {
                textBox.GotKeyboardFocus -= TextBox_GotKeyboardFocus;
                textBox.PreviewMouseLeftButtonDown -= TextBox_PreviewMouseLeftButtonDown;
            }
        }
    }

    private static void TextBox_GotKeyboardFocus(object sender, KeyboardFocusChangedEventArgs e)
    {
        if (sender is TextBox tb)
            tb.SelectAll();
    }

    private static void TextBox_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
    {
        if (sender is TextBox tb && !tb.IsKeyboardFocusWithin)
        {
            e.Handled = true;
            tb.Focus();
        }
    }
}
```

XAML 中开启该行为：

```xaml
<TextBox local:TextBoxBehaviors.SelectAllOnFocus="True"
         Text="{Binding SearchText}" />
```

---

## 15. 主题、皮肤与资源组织

### 15.1 基于 ResourceDictionary 的主题切换

1. 定义多套主题字典：

```xaml
<!-- Themes/LightTheme.xaml -->
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Color x:Key="PrimaryColor">#FF007ACC</Color>
    <SolidColorBrush x:Key="PrimaryBrush" Color="{StaticResource PrimaryColor}" />

    <Style TargetType="Button" x:Key="PrimaryButton">
        <Setter Property="Background" Value="{StaticResource PrimaryBrush}" />
        <Setter Property="Foreground" Value="White" />
    </Style>
</ResourceDictionary>

<!-- Themes/DarkTheme.xaml -->
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Color x:Key="PrimaryColor">#FF1E90FF</Color>
    <SolidColorBrush x:Key="PrimaryBrush" Color="{StaticResource PrimaryColor}" />

    <Style TargetType="Button" x:Key="PrimaryButton">
        <Setter Property="Background" Value="{StaticResource PrimaryBrush}" />
        <Setter Property="Foreground" Value="#EEEEEE" />
    </Style>
</ResourceDictionary>
```

2. 在运行时切换主题：

```csharp
public static class ThemeManager
{
    public static void ApplyTheme(Uri themeUri)
    {
        var app = Application.Current;
        var newDict = new ResourceDictionary { Source = themeUri };

        // 查找并替换现有 Theme 字典
        var oldDict = app.Resources.MergedDictionaries
            .FirstOrDefault(d => d.Source != null &&
                                 d.Source.OriginalString.Contains("Themes/"));

        if (oldDict != null)
            app.Resources.MergedDictionaries.Remove(oldDict);

        app.Resources.MergedDictionaries.Add(newDict);
    }
}
```

使用：

```csharp
ThemeManager.ApplyTheme(new Uri("Themes/LightTheme.xaml", UriKind.Relative));
ThemeManager.ApplyTheme(new Uri("Themes/DarkTheme.xaml", UriKind.Relative));
```

### 15.2 动态资源（DynamicResource）与主题

切换主题时，推荐使用 `DynamicResource`，让属性值在字典替换后自动更新：

```xaml
<Button Content="主题按钮"
        Style="{DynamicResource PrimaryButton}" />
```

区别：

- `StaticResource`：在解析 XAML 时一次性解析，不随主题切换而变化
- `DynamicResource`：运行时查找资源，资源变化时自动更新

### 15.3 字体、字号与统一样式

为保证全局统一风格，建议在 `App.xaml` 中定义基础样式：

```xaml
<Application.Resources>
    <Style TargetType="TextBlock">
        <Setter Property="FontFamily" Value="Microsoft YaHei" />
        <Setter Property="FontSize" Value="14" />
    </Style>

    <Style TargetType="Button">
        <Setter Property="FontFamily" Value="Microsoft YaHei" />
        <Setter Property="FontSize" Value="14" />
        <Setter Property="Padding" Value="10,4" />
    </Style>
</Application.Resources>
```

---

## 16. 本地化与多语言（Localization / Globalization）

### 16.1 使用资源文件（.resx）实现多语言

1. 在项目中添加 `Resources/Strings.resx`（默认语言），以及 `Strings.zh-CN.resx`、`Strings.en-US.resx` 等
2. 在 XAML 中通过 `x:Static` 引用强类型资源类：

```xaml
xmlns:res="clr-namespace:MyApp.Properties"

<TextBlock Text="{x:Static res:Resources.MainWindow_Title}" />
```

3. 在代码中切换 UI 文化：

```csharp
Thread.CurrentThread.CurrentUICulture = new CultureInfo("en-US");
```

### 16.2 使用绑定包装器进行动态语言切换

为了在运行时切换语言且自动刷新界面，可封装一个资源提供者：

```csharp
public class ResourceProvider : INotifyPropertyChanged
{
    private static readonly Lazy<ResourceProvider> _instance =
        new(() => new ResourceProvider());

    public static ResourceProvider Instance => _instance.Value;

    public string this[string key] => Properties.Resources.ResourceManager.GetString(key);

    public event PropertyChangedEventHandler PropertyChanged;

    public void RaiseLanguageChanged()
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(null));
    }
}
```

XAML 中绑定：

```xaml
<Window.DataContext>
    <local:MainViewModel />
</Window.DataContext>

<Window.Resources>
    <local:ResourceProvider x:Key="Res" />
</Window.Resources>

<TextBlock Text="{Binding Source={StaticResource Res}, Path=[MainWindow_Title]}" />
```

切换语言时：

```csharp
Thread.CurrentThread.CurrentUICulture = new CultureInfo("en-US");
ResourceProvider.Instance.RaiseLanguageChanged();
```

---

## 17. MVVM 框架与依赖注入

### 17.1 简易 ServiceLocator / IoC 容器

在不引入外部框架的情况下，可以实现一个极简服务定位器：

```csharp
public interface IServiceProvider
{
    T GetService<T>() where T : class;
}

public class SimpleContainer : IServiceProvider
{
    private readonly Dictionary<Type, Func<object>> _registrations = new();

    public void RegisterSingleton<TService>(TService instance)
        where TService : class
    {
        _registrations[typeof(TService)] = () => instance;
    }

    public void Register<TService>(Func<TService> factory)
        where TService : class
    {
        _registrations[typeof(TService)] = () => factory();
    }

    public T GetService<T>() where T : class
    {
        if (_registrations.TryGetValue(typeof(T), out var factory))
            return (T)factory();
        throw new InvalidOperationException($"服务未注册: {typeof(T).FullName}");
    }
}
```

在 `App.xaml.cs` 中配置：

```csharp
public partial class App : Application
{
    public static SimpleContainer Container { get; } = new SimpleContainer();

    protected override void OnStartup(StartupEventArgs e)
    {
        base.OnStartup(e);

        Container.RegisterSingleton<INavigationService>(new NavigationService());
        Container.RegisterSingleton<IDataService>(new DataService());
        Container.Register(() => new MainViewModel(Container.GetService<IDataService>()));
    }
}
```

Window 使用：

```csharp
public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
        DataContext = App.Container.GetService<MainViewModel>();
    }
}
```

### 17.2 Prism / MVVMLight 等框架的典型特性（概览）

常见 MVVM 框架通常提供：

- 基础 ViewModel 基类（实现 INotifyPropertyChanged）
- `DelegateCommand` / `RelayCommand` 等命令封装
- 区域导航（Region）与模块化（Module）
- 事件聚合器（EventAggregator）
- DI 容器集成（Unity、DryIoc、Autofac 等）

本篇以自实现为主，使用框架时可将这里的概念映射到对应框架 API 即可。

---

## 18. 调试 WPF 与常见工具

### 18.1 Snoop 与 WPF Inspector

这类工具可以在运行中的 WPF 应用上做“XAML 检查”：

- 查看视觉树 / 逻辑树结构
- 查看控件的当前 DataContext、绑定表达式与绑定错误
- 实时修改控件属性、样式，便于快速排查布局和绑定问题

基本使用步骤（以 Snoop 为例）：

1. 启动你的 WPF 应用
2. 打开 Snoop，选择要附加的进程
3. 在左侧树中选择某个控件，右侧查看 DataContext、绑定表达式和当前值
4. 查看“Binding Errors” 面板，快速定位所有绑定错误

### 18.2 常见绑定错误类型

1. 路径拼写错误：`Path=UserNmae`（少写或错写一个字母）
2. DataContext 为空：忘记设置窗口或控件的 DataContext
3. 访问层级过深且中间某级为 null：例如 `Path=User.Address.Street` 中 `Address` 为 null
4. 模板内未使用 `RelativeSource TemplatedParent`，导致找不到源

调试步骤建议：

- 打开 VS 的“输出”窗口，勾选 WPF 绑定调试输出
- 使用 Snoop 或 Live Visual Tree 观察 DataContext 和绑定路径

### 18.3 Live Visual Tree 与 Live Property Explorer

从 VS 2015 起，Visual Studio 提供了 Live Visual Tree：

- 可在运行时查看视觉树并选中控件
- 在 Live Property Explorer 中查看和修改属性值
- 可以直接跳转到 XAML 定义位置

---

## 19. 常见问题与排查清单

### 19.1 界面不刷新 / 绑定不更新

排查步骤：

1. 数据类是否实现 `INotifyPropertyChanged`？
2. 属性 Setter 中是否调用了 `OnPropertyChanged`？
3. 绑定 Mode 是否为 `TwoWay` 或 `OneWayToSource` 等合适模式？
4. 是否使用了 `UpdateSourceTrigger=PropertyChanged`（对 TextBox 尤其重要）？
5. 属性是否为 `public`，且名字与 Binding Path 完全一致？

### 19.2 命令不执行

1. 检查命令绑定：`Command="{Binding MyCommand}"`
2. 确认 DataContext 是否正确（命令定义在当前 DataContext 中？）
3. ICommand 的 `CanExecute` 是否返回 true？
4. 是否有其他 InputBinding/CommandBinding 截获了命令？

### 19.3 性能问题

1. 使用虚拟化控件（如大量列表时启用 `VirtualizingStackPanel`）
2. 避免在 `LayoutUpdated` 等高频事件中做重逻辑
3. 对复杂 DataTemplate 使用延迟加载、分页或数据虚拟化
4. 使用性能分析器查看 UI 线程的热点方法

---

## 20. 实战项目结构示例（中小型业务系统）

### 20.1 分层与文件夹划分

```text
MyBusinessApp
├─ MyBusinessApp.Domain           // 领域层（实体、接口、领域服务）
├─ MyBusinessApp.Infrastructure   // 基础设施（EF Core、仓储、外部服务调用）
├─ MyBusinessApp.Application      // 应用服务（用例、DTO、查询）
└─ MyBusinessApp.Presentation.Wpf // WPF 前端（本项目关注）

MyBusinessApp.Presentation.Wpf
├─ Views
│  ├─ Shell
│  │  ├─ ShellView.xaml
│  │  └─ ShellView.xaml.cs
│  ├─ Orders
│  │  ├─ OrderListView.xaml
│  │  └─ OrderDetailView.xaml
│  └─ Customers
│     ├─ CustomerListView.xaml
│     └─ CustomerDetailView.xaml
├─ ViewModels
│  ├─ ShellViewModel.cs
│  ├─ Orders
│  │  ├─ OrderListViewModel.cs
│  │  └─ OrderDetailViewModel.cs
│  └─ Customers
│     ├─ CustomerListViewModel.cs
│     └─ CustomerDetailViewModel.cs
├─ Services
│  ├─ Navigation
│  ├─ Dialogs
│  └─ Notification
├─ Controls
│  ├─ BusyIndicator.cs
│  └─ ValidatingTextBox.cs
├─ Converters
├─ Behaviors
├─ Resources
│  ├─ Styles
│  ├─ Themes
│  └─ Strings
└─ App.xaml / App.xaml.cs
```

### 20.2 一个典型用例：订单管理界面

1. `OrderListViewModel`：

- 暴露 `ObservableCollection<OrderDto> Orders`
- 暴露 `OrderDto SelectedOrder`
- 命令：`RefreshCommand`、`NewCommand`、`EditCommand`、`DeleteCommand`

2. `OrderListView` XAML：

- 左侧 DataGrid 展示订单列表
- 右侧区域使用 `ContentControl` 加载 `OrderDetailView`
- 工具栏按钮绑定到 ViewModel 命令

3. `OrderDetailViewModel`：

- 暴露当前编辑的 `OrderEditModel`
- 负责逐字段验证、保存/取消逻辑

4. 导航逻辑：

- 使用简单的 `INavigationService` 切换主区域显示的 View 与 ViewModel

---

以上扩展章节已经在原有基础上，从依赖属性、路由事件与命令、高级模板与自定义控件、主题和本地化、MVVM 工程化与调试实践等维度系统补充了大量细节与示例，使整篇 WPF 学习笔记更加接近一份“中高级开发手册”。

---

## 21. 文档生成、打印与报表

### 21.1 FlowDocument 与文档布局

`FlowDocument` 适合用于阅读型内容（文章、帮助文档），支持自动分页、重排和缩放：

```xaml
<FlowDocumentScrollViewer VerticalScrollBarVisibility="Auto" Zoom="100">
    <FlowDocument FontFamily="Microsoft YaHei" FontSize="14">
        <Section>
            <Paragraph FontSize="20" FontWeight="Bold">WPF 文档示例</Paragraph>
            <Paragraph Margin="0,10,0,0">
                WPF 的 FlowDocument 提供了类似网页的排版能力，适合做帮助文档、阅读器等。
            </Paragraph>

            <List MarkerStyle="Decimal">
                <ListItem>
                    <Paragraph>自动换行与重排</Paragraph>
                </ListItem>
                <ListItem>
                    <Paragraph>图片、表格、列表</Paragraph>
                </ListItem>
            </List>

            <Table CellSpacing="2">
                <Table.Columns>
                    <TableColumn Width="100" />
                    <TableColumn Width="200" />
                </Table.Columns>
                <TableRowGroup>
                    <TableRow>
                        <TableCell><Paragraph FontWeight="Bold">字段</Paragraph></TableCell>
                        <TableCell><Paragraph FontWeight="Bold">描述</Paragraph></TableCell>
                    </TableRow>
                    <TableRow>
                        <TableCell><Paragraph>Title</Paragraph></TableCell>
                        <TableCell><Paragraph>标题</Paragraph></TableCell>
                    </TableRow>
                </TableRowGroup>
            </Table>
        </Section>
    </FlowDocument>
</FlowDocumentScrollViewer>
```

`FlowDocument` 可以通过不同的查看器展示：`FlowDocumentScrollViewer`、`FlowDocumentReader`、`FlowDocumentPageViewer`。

### 21.2 打印可视树元素

WPF 提供 `PrintDialog` 与 `PrintVisual` 用于打印可视树中的元素：

```csharp
private void PrintButton_Click(object sender, RoutedEventArgs e)
{
    var dlg = new PrintDialog();
    if (dlg.ShowDialog() == true)
    {
        // 这里的 gridContent 是要打印的 UI 元素（例如 Grid 或 UserControl）
        dlg.PrintVisual(gridContent, "打印示例");
    }
}
```

注意：

- `PrintVisual` 适合简单打印，复杂报表可考虑 `FixedDocument` 或第三方报表工具
- 在高 DPI 环境下注意尺寸单位（WPF 使用 1/96 inch 的设备无关像素）

### 21.3 使用 FixedDocument 生成分页报表

`FixedDocument` 更接近“打印页面”的概念，可精确控制每页内容：

```csharp
public FixedDocument CreateSampleDocument()
{
    var doc = new FixedDocument();
    doc.DocumentPaginator.PageSize = new Size(827, 1169); // A4 96DPI 尺寸近似

    // 创建一页
    var pageContent = new PageContent();
    var fixedPage = new FixedPage { Width = 827, Height = 1169 };

    var title = new TextBlock
    {
        Text = "报表标题",
        FontSize = 24,
        Margin = new Thickness(50, 50, 0, 0)
    };
    FixedPage.SetLeft(title, 50);
    FixedPage.SetTop(title, 50);
    fixedPage.Children.Add(title);

    ((IAddChild)pageContent).AddChild(fixedPage);
    doc.Pages.Add(pageContent);

    return doc;
}
```

打印：

```csharp
var dlg = new PrintDialog();
if (dlg.ShowDialog() == true)
{
    var document = CreateSampleDocument();
    dlg.PrintDocument(document.DocumentPaginator, "固定文档打印");
}
```

### 21.4 导出为 XPS / PDF 基本思路

1. **导出 XPS**

- 使用 `XpsDocumentWriter` 将 `FixedDocument` 或 `FlowDocument` 输出到 XPS 文件

```csharp
using System.Windows.Xps;
using System.Windows.Xps.Packaging;

public void ExportToXps(FixedDocument document, string path)
{
    using var xpsDoc = new XpsDocument(path, FileAccess.Write);
    XpsDocumentWriter writer = XpsDocument.CreateXpsDocumentWriter(xpsDoc);
    writer.Write(document);
}
```

2. **导出 PDF**

- WPF 无内置 PDF 导出，常见做法：
  - 输出为 XPS，再通过第三方库转换为 PDF
  - 直接使用第三方报表 / PDF 库生成（如 iText7、PdfSharp 等）

---

## 22. WPF 3D（视图、模型与相机）

### 22.1 3D 场景基本构成

WPF 3D 主要由三部分组成：

1. **`Viewport3D`**：3D 场景的宿主（类似 3D 的 Canvas）
2. **`Camera`**：摄像机（`PerspectiveCamera` 或 `OrthographicCamera`）
3. **`Model3D`**：三维模型（`GeometryModel3D` + 材质 + 光照）

### 22.2 一个简单立方体示例

```xaml
<Viewport3D>
    <!-- 摄像机 -->
    <Viewport3D.Camera>
        <PerspectiveCamera Position="3,3,5"
                           LookDirection="-3,-3,-5"
                           UpDirection="0,1,0"
                           FieldOfView="45" />
    </Viewport3D.Camera>

    <!-- 场景内容 -->
    <ModelVisual3D>
        <ModelVisual3D.Content>
            <Model3DGroup>
                <!-- 灯光 -->
                <DirectionalLight Color="White" Direction="-1,-1,-2" />

                <!-- 立方体 -->
                <GeometryModel3D>
                    <GeometryModel3D.Geometry>
                        <MeshGeometry3D
                            Positions="-1,-1,1  1,-1,1  1,1,1  -1,1,1
                                       -1,-1,-1 1,-1,-1 1,1,-1 -1,1,-1"
                            TriangleIndices="0 1 2 0 2 3
                                             1 5 6 1 6 2
                                             5 4 7 5 7 6
                                             4 0 3 4 3 7
                                             3 2 6 3 6 7
                                             4 5 1 4 1 0" />
                    </GeometryModel3D.Geometry>
                    <GeometryModel3D.Material>
                        <DiffuseMaterial Brush="LightBlue" />
                    </GeometryModel3D.Material>
                </GeometryModel3D>
            </Model3DGroup>
        </ModelVisual3D.Content>
    </ModelVisual3D>
</Viewport3D>
```

### 22.3 3D 交互与变换

- 使用 `RotateTransform3D` + `AxisAngleRotation3D` 实现旋转
- 使用 `Transform3DGroup` 组合多种变换（缩放、平移、旋转）

```xaml
<GeometryModel3D x:Name="cube">
    <GeometryModel3D.Transform>
        <RotateTransform3D>
            <RotateTransform3D.Rotation>
                <AxisAngleRotation3D x:Name="rotation" Axis="0,1,0" Angle="0" />
            </RotateTransform3D.Rotation>
        </RotateTransform3D>
    </GeometryModel3D.Transform>
    <!-- Geometry & Material 省略 -->
</GeometryModel3D>
```

Code-behind 中通过动画旋转：

```csharp
var animation = new DoubleAnimation
{
    From = 0,
    To = 360,
    Duration = TimeSpan.FromSeconds(5),
    RepeatBehavior = RepeatBehavior.Forever
};
rotation.BeginAnimation(AxisAngleRotation3D.AngleProperty, animation);
```

---

## 23. Win32 / WinForms 互操作

### 23.1 在 WPF 中嵌入 WinForms 控件

通过 `WindowsFormsHost` 可以在 WPF 中使用 WinForms 控件：

```xaml
<Window x:Class="InteropDemo.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:wf="clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms"
        xmlns:wfi="clr-namespace:System.Windows.Forms.Integration;assembly=WindowsFormsIntegration">

    <Grid>
        <wfi:WindowsFormsHost>
            <wf:MaskedTextBox x:Name="winFormsMaskedTextBox" Mask="0000-0000-0000-0000" />
        </wfi:WindowsFormsHost>
    </Grid>
</Window>
```

注意：

- WinForms 控件与 WPF 控件是不同渲染栈，可能带来输入焦点、Z 顺序等问题
- 不建议大量混用，只在必要时互操作

### 23.2 在 WinForms 中嵌入 WPF 控件

WinForms 中通过 `ElementHost` 承载 WPF 控件：

```csharp
using System.Windows.Forms.Integration;

public partial class MainForm : Form
{
    public MainForm()
    {
        InitializeComponent();

        var host = new ElementHost { Dock = DockStyle.Fill };
        host.Child = new MyWpfUserControl(); // 任意 WPF UserControl
        Controls.Add(host);
    }
}
```

### 23.3 调用 Win32 API（窗口样式、玻璃效果等）

部分视觉效果需要直接使用 Win32 API（通过 P/Invoke）：

```csharp
[DllImport("user32.dll")]
private static extern int GetWindowLong(IntPtr hWnd, int nIndex);

[DllImport("user32.dll")]
private static extern int SetWindowLong(IntPtr hWnd, int nIndex, int dwNewLong);

private const int GWL_EXSTYLE = -20;
private const int WS_EX_TOOLWINDOW = 0x00000080;

public static void MakeToolWindow(Window window)
{
    var helper = new WindowInteropHelper(window);
    int style = GetWindowLong(helper.Handle, GWL_EXSTYLE);
    style |= WS_EX_TOOLWINDOW;
    SetWindowLong(helper.Handle, GWL_EXSTYLE, style);
}
```

调用时机通常在 `window.SourceInitialized` 事件中。

---

## 24. 部署、更新与配置管理

### 24.1 常见部署方式

1. **传统 MSI / Setup 项目**
   - 使用安装包部署到 Program Files
   - 可配置桌面图标、开始菜单、注册表等

2. **ClickOnce（已逐步边缘化，但仍存在）**
   - 支持自动更新和回滚
   - 差分更新，适合内网环境

3. **MSIX / Windows 应用打包**
   - 新一代打包格式，支持沙盒、增量更新
   - 可在 Microsoft Store 分发

4. **自包含 .NET 应用**
   - 使用 .NET Core/5+，发布为 self-contained，可以不依赖系统上的 .NET 安装

### 24.2 配置文件与环境区分

常见配置方式：

- `app.config` / `App.config`（.NET Framework）
- `appsettings.json`（.NET Core/5+）+ 自己解析

示例（appsettings.json）：

```json
{
  "Environment": "Development",
  "Api": {
    "BaseUrl": "https://api.example.com",
    "TimeoutSeconds": 30
  }
}
```

在 WPF 启动时读取：

```csharp
public static class AppSettings
{
    public static IConfigurationRoot Configuration { get; }

    static AppSettings()
    {
        var builder = new ConfigurationBuilder()
            .SetBasePath(AppDomain.CurrentDomain.BaseDirectory)
            .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true);

        Configuration = builder.Build();
    }
}
```

视图模型中注入 `IConfiguration` 或特定配置对象，避免直接依赖静态调用。

---

## 25. 无障碍（Accessibility）与键盘导航

### 25.1 AutomationPeer 与 UI 自动化

WPF 通过 UI 自动化（UIAutomation）支持读屏软件和自动化测试工具：

1. 默认控件都内置 AutomationPeer
2. 自定义控件可通过覆盖 `OnCreateAutomationPeer` 提供辅助信息

```csharp
public class BadgeAutomationPeer : FrameworkElementAutomationPeer
{
    public BadgeAutomationPeer(Badge owner) : base(owner) { }

    protected override string GetClassNameCore() => "Badge";
    protected override AutomationControlType GetAutomationControlTypeCore()
        => AutomationControlType.Text;

    protected override string GetNameCore()
    {
        var badge = (Badge)Owner;
        return badge.Content?.ToString() ?? base.GetNameCore();
    }
}

public class Badge : Control
{
    // 省略前文代码
    protected override AutomationPeer OnCreateAutomationPeer()
        => new BadgeAutomationPeer(this);
}
```

### 25.2 键盘导航与焦点管理

1. 使用 `TabIndex` 控制 Tab 焦点顺序：

```xaml
<TextBox TabIndex="0" />
<TextBox TabIndex="1" />
<Button TabIndex="2" />
```

2. 使用 `KeyboardNavigation.TabNavigation` 控制容器内部导航行为：

```xaml
<StackPanel KeyboardNavigation.TabNavigation="Cycle">
    <!-- 最后一个元素后回到第一个元素 -->
</StackPanel>
```

3. 使用 `AccessText` 与 `AccessKey` 提供快捷键访问：

```xaml
<Button>
    <AccessText Text="_保存" />
</Button>
```

按 `Alt+S` 即可激活按钮。

---

## 26. UI 自动化测试简述

### 26.1 UI 测试与单元测试的区别

- 单元测试：验证 ViewModel、服务、算法逻辑，无 UI 参与
- UI 测试：通过模拟用户行为（点击、输入）验证整体功能

### 26.2 使用 UIAutomation 做简单 UI 测试

示例（伪代码）：

```csharp
var process = Process.Start("MyWpfApp.exe");
Thread.Sleep(2000);

var root = AutomationElement.RootElement;
var appWindow = root.FindFirst(
    TreeScope.Children,
    new PropertyCondition(AutomationElement.NameProperty, "应用标题"));

var userNameBox = appWindow.FindFirst(
    TreeScope.Descendants,
    new PropertyCondition(AutomationElement.AutomationIdProperty, "UserNameTextBox"));

var valuePattern = (ValuePattern)userNameBox.GetCurrentPattern(ValuePattern.Pattern);
valuePattern.SetValue("admin");
```

配合 CI/CD，可在构建后自动跑一小部分关键 UI 测试用例。

---

## 27. 小结与下一步进阶方向

本篇笔记已经覆盖：

- 从 XAML 基础、布局、控件、数据绑定、样式与模板、MVVM，到性能优化与调试工具
- 依赖属性/附加属性、路由事件与命令高级用法、自定义控件与行为、主题与本地化
- 文档与打印、3D、Win32/WinForms 互操作、部署与配置管理、无障碍与 UI 自动化等

进一步进阶可以考虑：

1. 深入某个 MVVM 框架（Prism、ReactiveUI 等），构建模块化大型应用
2. 探索现代 UI 设计体系（Fluent 设计、Material Design in XAML）并应用到 WPF
3. 考虑与 Web / 移动端共享业务逻辑（如通过 .NET Standard 多平台共享）
4. 编写属于自己的 WPF 控件库或主题库，在多个项目中复用